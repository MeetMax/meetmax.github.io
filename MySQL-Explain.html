<!DOCTYPE html>
<html>
<head>
    <!-- Document Settings -->
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    <!-- Page Meta -->
    <title>Mysql之Explain详解</title>
    <meta name="description" content="Stay Hungry , Stay Foolish" />

    <!-- Mobile Meta -->
    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <!-- Brand icon -->
    <link rel="shortcut icon" href="/assets/images/favicon.ico" >

    <!-- Styles'n'Scripts -->
    <link rel="stylesheet" type="text/css" href="/assets/css/screen.css" />
    <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Merriweather:300,700,700italic,300italic|Open+Sans:700,400" />
    <link rel="stylesheet" type="text/css" href="/assets/css/syntax.css" />

    <!-- highlight.js -->
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.3.0/styles/default.min.css">
    <style>.hljs { background: none; }</style>

    <!-- Ghost outputs important style and meta data with this tag -->
        <link rel="canonical" href="http://localhost:4000//MySQL-Explain" />
    <meta name="referrer" content="origin" />
    <link rel="next" href="/page2/" />

    <meta property="og:site_name" content="Think Different" />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="Mysql之Explain详解" />
    <meta property="og:description" content="Stay Hungry , Stay Foolish" />
    <meta property="og:url" content="http://localhost:4000//MySQL-Explain" />
    <meta property="og:image" content="/assets/images/cover1.jpg" />

    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="Mysql之Explain详解" />
    <meta name="twitter:description" content="Stay Hungry , Stay Foolish" />
    <meta name="twitter:url" content="http://localhost:4000//MySQL-Explain" />
    <meta name="twitter:image:src" content="/assets/images/cover1.jpg" />

    <script type="application/ld+json">
{
    "@context": "http://schema.org",
    "@type": "Website",
    "publisher": "Think Different",
    "name": "Mysql之Explain详解",
    "url": "http://localhost:4000//MySQL-Explain",
    "image": "/assets/images/cover1.jpg",
    "description": "Stay Hungry , Stay Foolish"
}
    </script>

    <meta name="generator" content="Jekyll 3.0.0" />
    <link rel="alternate" type="application/rss+xml" title="Think Different" href="/feed.xml" />


</head>
<body class="home-template nav-closed">

    <!-- The blog navigation links -->
    <div class="nav">
    <h3 class="nav-title">Menu</h3>
    <a href="#" class="nav-close">
        <span class="hidden">Close</span>
    </a>
    <ul>
        <li class="nav-home " role="presentation"><a href="/">Home</a></li>
        <li class="nav-about " role="presentation"><a href="/about">About</a></li>
        <li class="nav-fables " role="presentation"><a href="/tag/fables">Fables</a></li>
        <li class="nav-speeches " role="presentation"><a href="/tag/speeches">Speeches</a></li>
        <li class="nav-fiction " role="presentation"><a href="/tag/fiction">Fiction</a></li>
        <li class="nav-author " role="presentation"><a href="/author/casper">Casper</a></li>
        <li class="nav-author " role="presentation"><a href="/author/edgar">Edgar</a></li>
        <li class="nav-author " role="presentation"><a href="/author/abraham">Abraham</a></li>
        <li class="nav-author " role="presentation"><a href="/author/martin">Martin</a></li>
        <li class="nav-author " role="presentation"><a href="/author/lewis">Lewis</a></li>
    </ul>
    <a class="subscribe-button icon-feed" href="/feed.xml">Subscribe</a>
</div>
<span class="nav-cover"></span>


    <div class="site-wrapper">

        <!-- All the main content gets inserted here, index.hbs, post.hbs, etc -->
        <!-- default -->

<!-- The comment above "< default" means - insert everything in this file into -->
    <!-- the [body] of the default.hbs template, which contains our header/footer. -->

<!-- Everything inside the #post tags pulls data from the post -->
<!-- #post -->

<header class="main-header post-head no-cover">
    <nav class="main-nav  clearfix">
        <a class="blog-logo" href="/"><img src="/assets/images/ghost.png" alt="Blog Logo" /></a>
        
    </nav>
</header>

<main class="content" role="main">

    <article class="post tag-fiction">

        <header class="post-header">
            <h1 class="post-title">Mysql之Explain详解</h1>
            <section class="post-meta">
            <!-- <a href='/'></a> -->

            
                
            
                
            
                
            
                
            
                
            
                
                    <a href='/author/meetmax'>MeetMax</a>
                
            
            <time class="post-date" datetime="2018-01-20">20 Jan 2018</time>
                <!-- [[tags prefix=" on "]] -->
                
                on
                
                    
                       <a href='/tag/mysql'>Mysql</a>,
                    
                
                    
                       <a href='/tag/数据库'>数据库</a>
                    
                
                
            </section>
        </header>

        <section class="post-content">

            <p>​	
​	
​	在工作中，经常会碰到一些慢查询，Explain 语句可以帮我们更详细的了解MySQL查询的执行计划，用法也很简单<code class="highlighter-rouge">Explain</code> 后面跟上<code class="highlighter-rouge">SELECT</code>语句即可。执行完之后，会显示一行有多个列的记录，可能很多人和我一样，对<code class="highlighter-rouge">EXPLAIN</code>里面字段的含义，并没有深入的去了解过，处于一知半解的状态，只知道一些最常见的。</p>

<p>​	下面我根据<a href="https://dev.mysql.com/doc/relnotes/mysql/5.7/en/">MySQL官方文档</a>，查阅了很多资料，再结合我自己的理解，对<code class="highlighter-rouge">EXPLAIN</code>的字段和值做了详细的描述，在总结过程中，也发现了自己的很多知识漏洞，很多时候，我总是会想当然的认为，这个就是对的，并没有严密逻辑验证，主要是懒的思考，正所谓好记性不如烂笔头，写的过程也是对自己知识点掌握程度的批判和考验。</p>

<h2 id="关于explain">关于EXPLAIN</h2>

<p>​	EXPLAIN返回一行记录，通过Explain可以获取到很多信息，如：不同表的查询顺序，查询用了哪些表，能使用哪些索引以及真正用到了哪些索引，用了哪种连接类型，是否有临时表和文件排序等。这些因素对查询的效率有直接的相关，想要使查询更高效，需要对这些条件做一个好的优化。</p>

<p>​	EXPLAIN有12个字段，每个字段对查询优化的权重比不一样，也就是说并不是所有字段都很重要。<code class="highlighter-rouge">type</code>,<code class="highlighter-rouge">key</code>,<code class="highlighter-rouge">Extra</code>字段相对其它字段来说，对查询效率的影响更大，优化查询的时候，先把注意力放到这些字段会比其它字段来得更加直接有效，下面开始具体内容。
​</p>

<h2 id="explain语法">EXPLAIN语法</h2>

<p>以<code class="highlighter-rouge">user_info</code>表为例：</p>

<pre><code class="language-mysql">explain select * from `user_info` where uid = 5
</code></pre>

<p>结果：</p>

<table>
  <thead>
    <tr>
      <th>id</th>
      <th>select_type</th>
      <th>table</th>
      <th>partitions</th>
      <th>type</th>
      <th>possible_keys</th>
      <th>key</th>
      <th>key_len</th>
      <th>ref</th>
      <th>rows</th>
      <th>filtered</th>
      <th>Extra</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>SIMPLE</td>
      <td>user_info</td>
      <td>NULL</td>
      <td>const</td>
      <td>PRIMARY</td>
      <td>PRIMARY</td>
      <td>8</td>
      <td>const</td>
      <td>1</td>
      <td>100.00</td>
      <td>NULL</td>
    </tr>
  </tbody>
</table>

<h2 id="explain字段说明">EXPLAIN字段说明</h2>

<p><strong>注</strong>： <em>标注星号的字段为重点</em></p>

<h4 id="id">id：</h4>

<p><code class="highlighter-rouge">SELECT</code>语句的标识符，代表<code class="highlighter-rouge">SELECT</code>查询在整个查询中的序号。这个值也可能为<code class="highlighter-rouge">NULL</code>，如果这一行是<code class="highlighter-rouge">UNION</code>的结果。</p>

<h4 id="select_type">select_type:</h4>

<p><code class="highlighter-rouge">SELECT</code>查询的类型，该类型的值有11种类型。例如，示例中的值为<code class="highlighter-rouge">SIMPLE</code>，表示该查询是一个简单的查询（即：没有子查询和<code class="highlighter-rouge">UNION</code>）。</p>

<p>####table:</p>

<p>大多数情况下表示输出行所引用的表名，它也可能是下列值之一：</p>

<h4 id="partitions">partitions:</h4>

<p>只对分区表有意义。意思是查询所匹配到的分区，如果该表为非分区表，则它的值为<code class="highlighter-rouge">NULL</code>。</p>

<h4 id="type">*type:</h4>

<p>查询的<code class="highlighter-rouge">join</code>类型，<strong>注意</strong>单表查询也被当做<code class="highlighter-rouge">join</code>的特例，并不一定要两张表。连接类型详情下面会详细介绍。</p>

<h4 id="possible_key">possible_key:</h4>

<p><code class="highlighter-rouge">possible_key</code>列是指，在查询中能够被MySQL用到的索引，但在实际情况中，不一定会被全部用到，这取决于MySQL优化器的选择，假设<code class="highlighter-rouge">possible_key</code>有<code class="highlighter-rouge">A,B,C</code>,3个索引，优化器经过分析认为<code class="highlighter-rouge">A</code>索引不需要用，那么实际执行的时候只会用到<code class="highlighter-rouge">B,C</code>索引。实际应用中，该列经常帮我们对<code class="highlighter-rouge">SQL</code>查询进行优化，如果它的值为<code class="highlighter-rouge">NULL</code>，说明没有能被用到的索引，这种情况下，需要调整<code class="highlighter-rouge">SQL</code>语句和优化表的索引。</p>

<h4 id="key">*key:</h4>

<p>查询中实际用到的索引，要注意，该列的值可能包含<code class="highlighter-rouge">possible_key</code>列中没有出现的索引，当查询满足<code class="highlighter-rouge">覆盖索引</code>的条件时，<code class="highlighter-rouge">possible_keys</code>列为<code class="highlighter-rouge">NULL</code>，索引仅在<code class="highlighter-rouge">key</code>列显示，MySQL只需要扫描索引树，不用到实际的数据行检索即可得到结果，查询会更高效，<code class="highlighter-rouge">Extra</code>列显示<code class="highlighter-rouge">USING INDEX</code>，则证明使用了覆盖索引。	也可以通过<code class="highlighter-rouge">FORCE INDEX</code>,<code class="highlighter-rouge">USE INDEX</code>或<code class="highlighter-rouge">IGNORE INDEX</code>来强制使用或忽略<code class="highlighter-rouge">possible_key</code>列中的索引。</p>

<p><strong>覆盖索引概念</strong>：</p>

<p>如果索引包含所有满足查询需要的数据的索引成为覆盖索引(Covering Index)。</p>

<p>假设有一个<code class="highlighter-rouge">user</code>表，假设索引<code class="highlighter-rouge">A</code>包含了<code class="highlighter-rouge">col1</code>,<code class="highlighter-rouge">col2</code>,<code class="highlighter-rouge">col3</code>三个字段，<code class="highlighter-rouge">criteria</code>为标准条件。</p>

<pre><code class="language-mysql">Query 1:
select * from user where criteria
</code></pre>

<p><code class="highlighter-rouge">Query 1</code>使用了索引查询，获取到数据行的主键，但是仍然需要根据主键值扫描实际的数据行。</p>

<pre><code class="language-mysql">Query 2:
select `col1`,`col2` where criteria
</code></pre>

<p><code class="highlighter-rouge">Query 2</code>中，索引<code class="highlighter-rouge">A</code>已经包含了它需的字段，也就是说<code class="highlighter-rouge">Query 2</code>不用再去实际的数据行获取数据了，只要扫描完索引树就行了，这样就省了一个步骤，索引树往往比实际的数据表小，所以效率很高，这就是<strong>覆盖索引</strong>。</p>

<h4 id="key_len">key_len:</h4>

<p>实际用到的索引字段长度，越短越好。</p>

<h4 id="ref">ref:</h4>

<p><code class="highlighter-rouge">ref</code>列显示哪个列或者常数和索引比较筛选出结果。</p>

<h4 id="rows">rows:</h4>

<p><code class="highlighter-rouge">rows</code>列表示MySQL认为执行查询必须检查的行数，对<code class="highlighter-rouge">Innodb</code>表来说，这是一个预估值，可能并不是确切的值。</p>

<h4 id="filtered">filtered:</h4>

<p>​	<code class="highlighter-rouge">filtered</code>的意思是，首先MySQL利用索引，例如，用<code class="highlighter-rouge">range</code>范围扫描出符合的行，如果扫描符合条件的估计值是100行，<code class="highlighter-rouge">rows</code>显示估计的值就是100，这一步是存储引擎根据索引筛选后的值，然后在Server层根据其余的<code class="highlighter-rouge">WHERE</code>条件过滤。</p>

<p>​	被过滤器过之后，符合条件的还剩下20行，也就是剩下20%，20%就是<code class="highlighter-rouge">filtered</code>中的值。很显然，直接在存储引擎层筛选出20行比先筛选出100行再过滤要更好，通常情况下，<code class="highlighter-rouge">filtered</code>的值越大可能意味着索引越好。</p>

<p>​	另一方面看，你也可以完全忽略<code class="highlighter-rouge">filtered</code>，因为这个值在大多数情况下只是一个不准确的估计，应该把注意力放到优化其它更有用的字段上，尤其是<code class="highlighter-rouge">type</code>,<code class="highlighter-rouge">key</code>,<code class="highlighter-rouge">Extra</code>。例如：尽量避免<code class="highlighter-rouge">filesort</code>排序，使用索引排序。或者有一个更好的<code class="highlighter-rouge">type</code>值，对性能的提升是非常巨大的，这种情况，即使<code class="highlighter-rouge">filtered</code>的值低也没关系。假设一个查询<code class="highlighter-rouge">A</code>， <code class="highlighter-rouge">type=all</code>,<code class="highlighter-rouge">filtered=0.1%</code>。那么首要先关注<code class="highlighter-rouge">type</code>字段，可通过添加索引来优化，可以先不管<code class="highlighter-rouge">filtered</code>。</p>

<p>​	所以对这个值不需要太认真，即使100%也不意味着索引一定好，反过来也不一定说明索引差，<code class="highlighter-rouge">type</code>比它更能说明索引的好坏。</p>

<h4 id="extra">*Extra:</h4>

<p>这个列包含Mysql解决查询的详细信息，详情见下方。</p>

<h2 id="explain字段值说明">EXPLAIN字段值说明：</h2>

<h4 id="select_type-1">select_type:</h4>

<table>
  <thead>
    <tr>
      <th>select_type 值</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>SIMPLE</td>
      <td>简单的<code class="highlighter-rouge">SELECT</code>查询（没有<code class="highlighter-rouge">UNION</code>和子查询）</td>
    </tr>
    <tr>
      <td>PRIMARY</td>
      <td>一个需要union操作或者含有子查询的select，位于最外层的单位查询的select_type即为primary。且只有一个</td>
    </tr>
    <tr>
      <td>UNION</td>
      <td><code class="highlighter-rouge">UNION</code>连接的<code class="highlighter-rouge">select</code>查询，除了第一个表外，第二个及以后的表select_type都是<code class="highlighter-rouge">union</code></td>
    </tr>
    <tr>
      <td>DEPENDENT UNION</td>
      <td>与<code class="highlighter-rouge">union</code>一样，出现在<code class="highlighter-rouge">union</code> 或<code class="highlighter-rouge">union all</code>语句中，但是这个查询要受到外部查询的影响</td>
    </tr>
    <tr>
      <td>UNION RESULT</td>
      <td><code class="highlighter-rouge">UNION</code>之后的结果集</td>
    </tr>
    <tr>
      <td>SUBQUERY</td>
      <td>除了from字句中包含的子查询外，其他地方出现的子查询都可能是subquery</td>
    </tr>
    <tr>
      <td>DEPENDENT SUBQUERY</td>
      <td>与dependent union类似，表示这个subquery的查询要受到外部表查询的影响</td>
    </tr>
    <tr>
      <td>DERIVED</td>
      <td><code class="highlighter-rouge">FROM</code>字句中出现的子查询。语法：<code class="highlighter-rouge"> SELECT ... FROM (subquery) [AS] tbl_name ...</code></td>
    </tr>
    <tr>
      <td>MATERIALIZED</td>
      <td>被物化的子查询</td>
    </tr>
    <tr>
      <td>UNCACHEABLE SUBQUERY</td>
      <td>对于外层的主表，子查询不可被物化，每次都需要计算（耗时操作）</td>
    </tr>
    <tr>
      <td>UNCACHEABLE UNION</td>
      <td>UNION操作中，内层的不可被物化的子查询（类似于UNCACHEABLE SUBQUERY）</td>
    </tr>
  </tbody>
</table>

<p>通过 **物化 ** 优化子查询的原理：</p>

<p>​	优化器使用物化的方式能让子查询更高效的执行，类似缓存技术，把第一次查询的结果存起来，避免多次的耗时操作，同时也有它自身的限制，不是所有子查询都能被物化的。物化技术把子查询产生的结果放在一个临时表中，如果数据量小的话，通常是在内存中完成，数据大的时候就降级到磁盘进行，速度也会慢很多。首先，MySQL得到子查询的结果，然后把结果放到临时表中，在随后的任何时间，当需要这个结果时，MySQ就再次引用这个临时表，不需要再执行计算了。优化器可能会使用哈希索引（<strong>复杂度为O(1)，很快</strong>）来快速且低成本的查找表，这个索引是唯一的，避免了重复，能使表更小。</p>

<pre><code class="language-mysql">SELECT * FROM t1
WHERE t1.a IN (SELECT t2.b FROM t2 WHERE where_condition);
</code></pre>

<h4 id="type连接类型">type（连接类型）：</h4>

<ul>
  <li>
    <p><code class="highlighter-rouge">system</code></p>

    <p>当表只有一行数据的时候，这是<code class="highlighter-rouge">const</code>连接类型的特例。</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">const</code></p>

    <p>表中最多只有一行匹配，在查询开始时被读取。因为只有一行，该行中列的值可以被优化器的其余部分视为常量。<code class="highlighter-rouge">const</code>表非常快，因为他们仅被读取一次。将<code class="highlighter-rouge">PRIMARY KEY</code> 或 <code class="highlighter-rouge">UNIQUE INDEX</code>索引和常量值比较时,会使用<code class="highlighter-rouge">const</code>。例如：</p>

    <pre><code class="language-mysql">SELECT * FROM tbl_name WHERE primary_key=1;

SELECT * FROM tbl_name
WHERE primary_key_part1=1 AND primary_key_part2=2;
</code></pre>
  </li>
  <li>
    <p><code class="highlighter-rouge">eq_ref</code></p>

    <p>假设<code class="highlighter-rouge">A JOIN B</code>，<code class="highlighter-rouge">B</code>表读取<code class="highlighter-rouge">A</code>表的各个行组合的一行时，通过<code class="highlighter-rouge">B</code>表的<code class="highlighter-rouge">PRIMARY KEY</code>或<code class="highlighter-rouge">UNIQUE NOT NULL</code>索引列连接时，优化器会使用<code class="highlighter-rouge">eq_ref</code>类型，这是除了<code class="highlighter-rouge">system</code>和<code class="highlighter-rouge">const</code>之外最快的<code class="highlighter-rouge">JOIN</code>类型。</p>

    <p>举例说明：</p>

    <p>表<code class="highlighter-rouge">tableA</code>,有（id,text）字段，id为<code class="highlighter-rouge">PRIMARY KEY</code>,A表数据为：</p>

    <table>
      <thead>
        <tr>
          <th>id</th>
          <th>text</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>1</td>
          <td>HELLO</td>
        </tr>
        <tr>
          <td>2</td>
          <td>THANK</td>
        </tr>
      </tbody>
    </table>

    <p>表<code class="highlighter-rouge">tableB</code>有（id,text）字段，id为<code class="highlighter-rouge">PRIMARY KEY</code>,B表数据为：</p>

    <table>
      <thead>
        <tr>
          <th>id</th>
          <th>text</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>1</td>
          <td>WORLD</td>
        </tr>
        <tr>
          <td>2</td>
          <td>YOU</td>
        </tr>
      </tbody>
    </table>

    <p>现在通过<code class="highlighter-rouge">JOIN</code>将两个表关联起来</p>

    <pre><code class="language-mysql">SELECT A.text,B.text 
FROM tableA AS A,tableB as B 
WHERE A.id=B.id
</code></pre>

    <p>这个连表查询是非常快的，因为在<strong>A表中扫描的每一行，在B表中也仅一行满足条件</strong>。</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">ref</code></p>

    <p>​	<code class="highlighter-rouge">A JOIN C</code>时，A表中的每一行不是唯一的，对单表查询也一样，有多个满足条件的行，查询的<code class="highlighter-rouge">KEY</code>是单个索引或复合索引的最左前缀(<strong>不是唯一索引和主键</strong>)，也就是说C表的<code class="highlighter-rouge">id</code>是一个非唯一索引。这种情况下，优化器会使用<code class="highlighter-rouge">ref</code>优化，如果只有少部分行(<strong>rows</strong>)满足条件，这个连接类型(<code class="highlighter-rouge">join type</code>)是很好的。<code class="highlighter-rouge">ref</code>用于索引的比较操作，<strong>注意</strong>：仅对于<code class="highlighter-rouge">=</code>,<code class="highlighter-rouge">&lt;=&gt;</code> 操作有效，对于<code class="highlighter-rouge">&gt;</code>,<code class="highlighter-rouge">&lt;</code>,<code class="highlighter-rouge">BETWEEN</code>,<code class="highlighter-rouge">IN</code>的范围操作优化器可能会使用<code class="highlighter-rouge">range</code>类型(<strong>见下方</strong>),也可能是<code class="highlighter-rouge">ALL</code>全表扫描。</p>

    <p>举例说明：</p>

    <p>现在有<code class="highlighter-rouge">tableC</code>，<code class="highlighter-rouge">id</code>为索引，不唯一。数据为：</p>

    <table>
      <thead>
        <tr>
          <th>id (非唯一索引)</th>
          <th>text</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>1</td>
          <td>HANGZHOU</td>
        </tr>
        <tr>
          <td>1</td>
          <td>SHANGHAI</td>
        </tr>
      </tbody>
    </table>

    <p>现在通过<code class="highlighter-rouge">LEFT JOIN</code>将<code class="highlighter-rouge">A</code>和<code class="highlighter-rouge">C</code>关联起来:</p>

    <pre><code class="language-mysql">SELECT A.text,C.text 
FROM `tableA` AS A 
LEFT JOIN `tableC` AS C ON A.id=C.id
</code></pre>

    <p>这个<code class="highlighter-rouge">JOIN</code>不像之前的那么快，因为在表A中扫描的每一行，在表C中可能有很多行满足条件，C的id不是唯一索引。</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">fulltext</code></p>

    <p>使用了全文索引，<code class="highlighter-rouge">Innodb</code>不支持全文索引。</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">ref_or_null</code></p>

    <p>如果一个查询的<code class="highlighter-rouge">WHERE</code>子句中包含<code class="highlighter-rouge">colA IS NULL</code>的条件，但是<code class="highlighter-rouge">colA</code>已经被声明为<code class="highlighter-rouge">NOT NULL</code>，此时优化器会使用<code class="highlighter-rouge">ref_or_null</code>类型。</p>

    <pre><code class="language-mysql">SELECT * FROM ref_table
WHERE key_column=expr OR key_column IS NULL;
</code></pre>
  </li>
  <li>
    <p><code class="highlighter-rouge">index_merge</code></p>

    <p>​	在MYSQL5.0之前是没有索引合并功能的，假设<code class="highlighter-rouge">A</code>表有3个单独的索引<code class="highlighter-rouge">col1</code> ,<code class="highlighter-rouge">col2</code>,<code class="highlighter-rouge">col3</code>，然后执行如下<code class="highlighter-rouge">SQL</code>:</p>

    <pre><code class="language-Mysql">SELECT * FROM A WHERE col1=1 AND col2=2 AND col3=3
</code></pre>

    <p>实际查询中只有一个索引能被用到，这种情况，只能通过建立复合索引<code class="highlighter-rouge">(col1,col2,col3)</code>才能在索引中用到所有字段。</p>

    <p>​	5.0之后有了索引合并，当检索数据行时出现多个范围扫描条件时，在满足索引合并前提条件时(单个索引覆盖<code class="highlighter-rouge">WHERE</code>条件的字段)，MySQL优化器可能会使用索引合并(不一定)，首先分别对多个索引进行扫描，然后合并来自单个表的扫描结果，它不能合并多个表的扫描结果，合并的方式有3种：</p>

    <ul>
      <li><code class="highlighter-rouge">unions</code>：索引取并集</li>
      <li><code class="highlighter-rouge">intersections</code>：索引取交集</li>
      <li><code class="highlighter-rouge">Sort-Union</code>:先对取出的数据按主键排序，再取并集</li>
    </ul>

    <p><strong>索引合并条件</strong>：</p>

    <ol>
      <li>
        <p><code class="highlighter-rouge">WHERE</code>子句中的范围条件，<code class="highlighter-rouge">WHERE</code>中出现字段必须被索引覆盖，如果<code class="highlighter-rouge">colA</code>没添加索引，则只会对<code class="highlighter-rouge">colB</code>和<code class="highlighter-rouge">colC</code>进行索引合并，<code class="highlighter-rouge">Extra</code>字段显示<code class="highlighter-rouge">Using intersect(colB,colC);</code>，<code class="highlighter-rouge">type</code>为<code class="highlighter-rouge">index_merge</code>，则说明用到了索引合并。</p>

        <pre><code class="language-mysql">WHERE colA = const1 AND colB = const2 AND colC = const3
</code></pre>
      </li>
      <li>
        <p><code class="highlighter-rouge">Innodb</code>表中的主键的任何范围条件，<code class="highlighter-rouge">&gt;</code>,<code class="highlighter-rouge">&lt;</code>,<code class="highlighter-rouge">&lt;&gt;</code>等。</p>

        <pre><code class="language-mysql">SELECT * FROM innodb_table
  WHERE primary_key &lt; 10 AND key_col1 = 20;
</code></pre>
      </li>
    </ol>

    <p>​        满足了条件，MYSQL会选择索引行数最少的字段对索引结果进行合并，最终使用哪个索引字段来合并也不一定，也可能不使用合并，这取决于优化器，如果优化器认为没必要使用索引合并优化，就会使用其它优化，也许会选择<code class="highlighter-rouge">type</code> 为<code class="highlighter-rouge">range</code>或更高效的<code class="highlighter-rouge">ref</code>的优化。</p>

    <p>​	当优化器决定使用索引合并优化，如果<code class="highlighter-rouge">WHERE</code>条件用<code class="highlighter-rouge">AND</code>连接，优化器会使用<code class="highlighter-rouge">INTERSECTIONS</code>合并算法，对多个索引扫描的结果取交集。如果用<code class="highlighter-rouge">OR</code>连接，优化器会选择<code class="highlighter-rouge">UNIONS</code>或<code class="highlighter-rouge">SORT-UNIONS</code>合并算法，对多个索引扫描的结果取合集，<code class="highlighter-rouge">SORT-UNIONS</code>和<code class="highlighter-rouge">UNIONS</code>的主要区别是，前者在扫描完数据时，需要先对数据按主键排序，再取它们的合集。</p>

    <p>​	 在<code class="highlighter-rouge">WHERE</code>子句中使用<code class="highlighter-rouge">AND</code>时，使用复合索引比索引合并更高效，因为复合索引只用一个索引筛选，没有匹配合并的过程，这个过程节省了很多时间。</p>

    <p>​	在使用<code class="highlighter-rouge">OR</code>时，复合索引是不起作用的，这种情况下，使用<code class="highlighter-rouge">UNIONS</code>索引合并效果更好。如果不想使用某种索引合并，也可以选择关闭。可通过<code class="highlighter-rouge">optimzer_switch</code>系统变量查看各个索引合并的开启状况。如下：</p>

    <pre><code class="language-mysql">SELECT @@optimizer_switch
</code></pre>

    <p>索引合并算法的默认都是开启的，可以通过关闭某个合并算法。例如：</p>

    <pre><code class="language-mysql">SET optimizer_switch = 'index_merge_intersection=off'
</code></pre>
  </li>
  <li>
    <p><code class="highlighter-rouge">unique_subquery</code></p>

    <p>这种类型是<code class="highlighter-rouge">eq_ref</code>类型在子查询中的替代类型。例如</p>

    <pre><code class="language-mysql">SELECT * FROM A WHERE
value IN (SELECT id FROM B WHERE some_expr)
</code></pre>

    <p><code class="highlighter-rouge">B</code>表中的<code class="highlighter-rouge">id</code>在A表中有唯一对应的记录。</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">range</code></p>

    <p>​	在<code class="highlighter-rouge">WHERE</code>子句中，执行<code class="highlighter-rouge">&gt;</code>,<code class="highlighter-rouge">&lt;</code>,<code class="highlighter-rouge">&lt;&gt;</code>,<code class="highlighter-rouge">=</code>,<code class="highlighter-rouge">BETWEEN</code>,<code class="highlighter-rouge">IN()</code> 等操作时，MySQL可能会(<strong>不一定</strong>)使用<code class="highlighter-rouge">range</code>类型，<code class="highlighter-rouge">Explain</code>中<code class="highlighter-rouge">key</code>列的值就是实际用到的索引，<code class="highlighter-rouge">key_len</code>是它们中最长的索引的长度。如果优化器认为使用索引筛选没有全表扫描来得及，例如：条件筛选后的行占全表的50%以上，即使有索引可用，优化器也会选择全表扫描，即<code class="highlighter-rouge">type=ALL</code>。</p>

    <p>​	为什么呢？解释这个问题之前，需要先了解几个概念。对<code class="highlighter-rouge">Innodb</code>表来说，每个表都有一个<strong>聚簇索引</strong>，InnoDB的<strong>聚簇索引</strong>实际上在同一个结构中保存了B-Tree索引和数据行信息。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个<strong>聚簇索引</strong>。<strong>二级索引</strong>存储的是记录的主键，而不是数据存储的地址，索引数据和存储数据是分离的，唯一索引、普通索引、前缀索引等都是二级索引。实际上，InnoDB在查询任何数据时，最后都是通过主键来查询的。首先我们根据索引条件在索引树上扫描出对应的主键值。然后根据这个值去聚簇索引总超找到对应的行(<strong>如果是覆盖索引则省略这一步</strong>)。</p>

    <p>​	在某些情况下，索引条件扫描出的数据行非常大，可能占了全表的50%，此时再根据主键找到对应的数据块是不划算。主键的BTree查找属于文件的随机搜索，但是如果随机搜索文件数据的目的是为了查找一半的数据，这并不是最优化的，只要对数据文件进行大量的顺序读写要更快，这种情况下，索引会被忽略。</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">index</code></p>

    <p>​	<code class="highlighter-rouge">index</code>类型和<code class="highlighter-rouge">ALL</code>类型几乎相同。有两种情况：</p>

    <ol>
      <li>若<code class="highlighter-rouge">SELECT</code>中列全部被索引覆盖，所需要的数据可以直接在索引中读取，MySQL只需对索引树进行扫描，这通常比扫描实际数据行要快，因为索引树通常比数据表更小，这种情况下，<code class="highlighter-rouge">Extran</code>的值会显示<code class="highlighter-rouge">USING INDEX</code>。</li>
      <li>使用索引中读取的主键值，按索引顺序对全表进行扫描，此时<code class="highlighter-rouge">Extra</code>中没有<code class="highlighter-rouge">USING INDEX</code>。</li>
    </ol>
  </li>
  <li>
    <p><code class="highlighter-rouge">ALL</code></p>

    <p>对表的每一行进行扫描，这是最糟糕的情况。一般，你可以通过添加索引来避免这种情况发生。</p>
  </li>
</ul>

<h4 id="extra列值的含义">Extra列值的含义:</h4>

<p>​	<code class="highlighter-rouge">Extra</code>列包含了MySQL处理查询的一些额外信息，下面的列出了Extra中可能出现的值，如果你想让查询尽可能的快，应该注意下<code class="highlighter-rouge">Extra</code>字段中是否出现了<code class="highlighter-rouge">using filesort</code> 和<code class="highlighter-rouge">using temporary</code>。下面只列除了在实际应用中经常会出现，相对比较重要的一部分，若描述的不够详细，可查看MySQL官方文档。</p>

<ul>
  <li>
    <p><code class="highlighter-rouge">const row not found</code></p>

    <pre><code class="language-mysql">SELECT * FROM A
</code></pre>

    <p>如果A表为空，则会出现改值。</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">DISTINCT</code></p>

    <p>mysql在寻找不同的值，当它找到第一个匹配的行之后，就停止搜索更多的行了。例子：</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">no matching row in const table</code></p>

    <p>用唯一索引或者主键查询时，没有匹配到的数据。</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">Not exists</code></p>

    <p>MySQL优化了<code class="highlighter-rouge">LEFT JOIN</code>，一旦它找到了匹配<code class="highlighter-rouge">LEFT JOIN</code>标准的行，就不再搜索了，。例如：</p>

    <pre><code class="language-mysql">SELECT * FROM t1 LEFT JOIN t2 ON t1.id=t2.id
 WHERE t2.id IS NULL;
</code></pre>
  </li>
  <li>
    <p><code class="highlighter-rouge">Using filesort</code></p>

    <p>​	这个值表示，MySQL必须对检索到的结果进行额外的排序。排序是按照连接类型遍历所有行并存储排序键和指向行的指针，以匹配满足where子句条件的所有行，然后对键进行排序，并按排序顺序检索行。根据不同情况，MySQL会选择不同的排序算法，在数据比较小的时候，MySQL会利用排序缓冲区作为优先级队列将结果在内存中排序，否则只能通过合并文件的方式合并，那会慢很多，排序缓冲区的大小取决于<code class="highlighter-rouge">sort_buffer_size</code>变量的大小。</p>

    <p>​	总之，当看到<code class="highlighter-rouge">filesort</code>的时候就应该引起重视，通过优化索引来避免额外的文件排序，这对性能影响是很大的。</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">Using index</code></p>

    <p>单个索引覆盖了<code class="highlighter-rouge">SELECT</code>的所有列（即：覆盖索引），不需要对实际的数据行进行扫描。</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">Using index condition</code></p>

    <p>​	Index Condition Pushdown (ICP)是MySQL 5.6 版本中的新特性,是一种在存储引擎层使用索引过滤数据的一种优化方式。当关闭ICP时,index 仅仅是data access 的一种访问方式，存储引擎通过索引回表获取的数据会传递到MySQL Server 层进行where条件过滤。</p>

    <p>​	当打开ICP时,如果部分where条件能使用索引中的字段,MySQL Server 会把这部分下推到引擎层,可以利用index过滤的where条件在存储引擎层进行数据过滤,而非将所有通过index access的结果传递到MySQL server层进行where过滤.
优化效果:ICP能减少引擎层访问基表的次数和MySQL Server 访问存储引擎的次数,减少io次数，提高查询语句性能。</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">Using index for group-by</code></p>

    <p>和<code class="highlighter-rouge">USING INDEX</code>很相似，区别是，当查询语句中含有<code class="highlighter-rouge">DISTINCT</code>和<code class="highlighter-rouge">GROUP BY</code>操作时，仅需访问索引树，不需要访问实际的表时，使用该优化。</p>
  </li>
  <li>
    <p>``Using sort_union(…)<code class="highlighter-rouge">, </code>Using union(…)<code class="highlighter-rouge">, </code>Using intersect(…)`</p>

    <p>当查询产生索引合并时会显示该值，<code class="highlighter-rouge">type</code>为<code class="highlighter-rouge">index_merge</code>。</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">Using temporary</code></p>

    <p>为了处理查询，MySQL必须建立一个临时表才能产生结果。典型的情况是，在使用<code class="highlighter-rouge">GROUP BY</code>和<code class="highlighter-rouge">ORDER BY</code>子句时，两者使用了不同的列会导致产生临时表。</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">Using where</code></p>

    <p><code class="highlighter-rouge">using where</code> 是指使用<code class="highlighter-rouge">WHERE</code>或<code class="highlighter-rouge">ON</code>子句，MySQL <code class="highlighter-rouge">Server</code>层收到存储引擎返回的结果时，需要对结果再次过滤，不需要返回所有结果，注意<code class="highlighter-rouge">LIMIT</code>不算限制条款。如果没有用到索引<code class="highlighter-rouge">using where</code>只是说明，使用了顾虑条件过滤。</p>
  </li>
</ul>

<h2 id="参考">参考</h2>

<p><a href="https://dev.mysql.com/doc/refman/5.7/en">MySQL官方文档</a></p>



        </section>

        <footer class="post-footer">

            <!-- Everything inside the #author tags pulls data from the author -->
            <!-- #author-->
            
                
            
                
            
                
            
                
            
                
            
                
                    
                        <figure class="author-image">
                            <a class="img" href="/author/meetmax" style="background-image: url(/assets/images/martin.jpg)"><span class="hidden">meetmax's Picture</span></a>
                        </figure>
                    

                    <section class="author">
                        <h4><a href="/author/meetmax">MeetMax</a></h4>

                        
                            <p> An American pastor, activist, humanitarian. People know me for leading the African-American Civil Rights movement using nonviolent civil disobedience.</p>
                        
                        <div class="author-meta">
                            <span class="author-location icon-location"> Memphis, Tennessee</span>
                            <span class="author-link icon-link"><a href="http://jekyller.github.io/jasper/"> jekyller.github.io/jasper</a></span>
                        </div>
                    </section>

                    <!-- /author  -->

                    <section class="share">
                        <h4>Share this post</h4>
                        <a class="icon-twitter" href="http://twitter.com/share?text=Mysql之Explain详解&amp;url=http://localhost:4000MySQL-Explain"
                            onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
                            <span class="hidden">Twitter</span>
                        </a>
                        <a class="icon-facebook" href="https://www.facebook.com/sharer/sharer.php?u=http://localhost:4000MySQL-Explain"
                            onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
                            <span class="hidden">Facebook</span>
                        </a>
                        <a class="icon-google-plus" href="https://plus.google.com/share?url=http://localhost:4000MySQL-Explain"
                           onclick="window.open(this.href, 'google-plus-share', 'width=490,height=530');return false;">
                            <span class="hidden">Google+</span>
                        </a>
                    </section>
                
            

            <!-- Add Disqus Comments -->
            

        </footer>

    </article>

</main>

<aside class="read-next">

    <!-- [[! next_post ]] -->
    
        <a class="read-next-story no-cover" href="/UNIX-IPC">
            <section class="post">
                <h2>Unix进程间通信(IPC)</h2>
                <p>### IPC概念: > **进程间通信**（**IPC**，*Inter-Process Communication*），指至少两个[进程](https://zh.wikipedia.org/wiki/%E8%BF%9B%E7%A8%8B)或[线程](https://zh.wikipedia.org/wiki/%E7%BA%BF%E7%A8%8B)间传送数据或信号的一些技术或方法。进程是[计算机系统](https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F)分配资源的最小单位(严格说来是线程)。每个进程都有自己的一部分独立的系统资源，彼此是隔离的。为了能使不同的进程互相访问资源并进行协调工作，才有了进程间通信。举一个典型的例子，使用进程间通信的两个应用可以被分类为客户端和服务器（见**主从式架构**），客户端进程请求数据，服务端回复客户端的数据请求。有一些应用本身既是服务器又是客户端，这在**分布式计算**中，时常可以见到。这些[进程](https://zh.wikipedia.org/wiki/%E8%BF%9B%E7%A8%8B)可以运行在同一计算机上或网络连接的不同计算机上。 > > 进程间通信技术包括消息传递、同步、共享内存和[远程过程调用](https://zh.wikipedia.org/wiki/%E8%BF%9C%E7%A8%8B%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8)。IPC是一种标准的[Unix](https://zh.wikipedia.org/wiki/Unix)通信机制。 > > 使用IPC 的理由： > > -...</p>
            </section>
        </a>
    
    <!-- [[! /next_post ]] -->
    <!-- [[! prev_post ]] -->
    
        <a class="read-next-story prev " style="background-image: url(/assets/images/cover7.jpg)" href="/the-businessman-and-fisherman">
            <section class="post">
                <h2>The Businessman & the fisherman</h2>
                <p>An American businessman took a vacation to a small coastal Mexican village on doctor’s orders....</p>
            </section>
        </a>
    
    <!-- [[! /prev_post ]] -->
</aside>

<!-- /post -->


        <!-- The tiny footer at the very bottom -->
        <footer class="site-footer clearfix">
          <section class="copyright"><a href="/">Think Different</a> &copy; 2018</section>
          <section class="poweredby">Proudly published with <a href="https://jekyllrb.com/">Jekyll</a> using <a href="https://github.com/jekyller/jasper">Jasper</a></section>
        </footer>
    </div>
    <!-- highlight.js -->
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.3.0/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

    <!-- jQuery needs to come before `` so that jQuery can be used in code injection -->
    <script type="text/javascript" src="//code.jquery.com/jquery-1.12.0.min.js"></script>
    <!-- Ghost outputs important scripts and data with this tag -->
    <!--  -->
    <!-- Add Google Analytics  -->
        <!-- Google Analytics Tracking code -->
     <script>
	    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	    ga('create', 'UA-69281367-1', 'auto');
	    ga('send', 'pageview');

     </script>
    <!-- Fitvids makes video embeds responsive and awesome -->
    <script type="text/javascript" src="/assets/js/jquery.fitvids.js"></script>
    <!-- The main JavaScript file for Casper -->
    <script type="text/javascript" src="/assets/js/index.js"></script>

</body>
</html>
