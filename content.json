{"meta":{"title":"MeetMax","subtitle":null,"description":null,"author":"MeetMax","url":"https://meetmax.github.io"},"pages":[],"posts":[{"title":"","slug":"Redis应用场景浅析","date":"2018-03-17T13:00:09.478Z","updated":"2018-03-17T13:00:09.479Z","comments":true,"path":"2018/03/17/Redis应用场景浅析/","link":"","permalink":"https://meetmax.github.io/2018/03/17/Redis应用场景浅析/","excerpt":"","text":"Redis应用场景浅析String–字符串redis最能想到的就是使用序列化的字符串缓存，通常为json格式，把一些在mysql中需要大量sql查询操作和计算得到的数据缓存起来，再次访问的时候就可以直接读取数据，可有效降低数据库的压力，例如网站首页的某些排名信息，查询比较复杂，但是对实时性要求没那么高的，可以设置一个定时过期的缓存，这是最简单的缓存应用场景，redis提供了丰富的数据结构，可以用在很多web应用的场景。 Hash–哈希哈希表是redis中很有用的数据结构，有时候我们需要存储结构话的数据，例如用户的登录信息1234uid:1 // 用户uidusername:xxx // 用户名age:18 // 年龄head:xxx //头像 String模式按照普通缓存的模式，存储这个结构需要先将其序列化，转换成json字符串，以user-uid为键名，这样做有个问题，假如说现在需要修改head字段，我需要经历如下步骤： 根据键名user-1获取到json字符串 解析json 修改结构体中的head字段 再次序列化成json set key 存储 Hash模式接下来使用Hash来存储，使用HMSET命令存储所有字段1HMSET user-1 uid 1 username xxx age 18 head:xxx 这时候需要修改字段head仅需一条命令即可：1HSET user-1 head zzz 相比之下是不是简单了很多，Hash模式不仅操作大大简化，而且节省了String模式中大量的序列化和反序列化的性能消耗。 List – 列表List在redis中的应用也比较广泛，最典型的就是消息队列，在某些高并发场景下，由于mysql存储介质为磁盘，在写入性能上由于磁盘的读写速度限制，它的写入速度可能达不到要求。但是redis不一样，redis是完全基于内存数据库nosql，没有I/O瓶颈，写入和读取速度都非常快，这也是redis流行的原因。假设现在要做一个商城的秒杀活动，在同一时刻必然会有大量的订单提交操作，mysql可能来不及写入，会导致其它用户阻塞，糟糕的情况下甚至系统奔溃，影响用户体验。在这种场景下就可以通过消息队列来处理，即： 先把提交的订单信息写入消息队列，可通过LPUSH和RPOP命令实现入队和出队的操作。 通过异步程序将订单存储到mysql 另一种场景是可作为IM聊天系统的timeline模型，即每个用户对应一个timeline模型，根据时间顺序排列，每个用户通过timeline获取消息 Set – 集合集合和List的类似，区别是集合是可以自动排重的，且集合是无序的。例如：存储某个用户的所有粉丝和所有的好友等。 Sorted Set 有序集合有序集合根据score字段来排序，通过ZADD可添加一个有序集合，例如：1ZADD page_rank 10 google.com 上面命令的意思是在page_rank集合中添加字符串google.com，score为10。有序集合可用来数据分页，例如我们查询用户积分前100名的用户，每页20条展示，通过ZRANGE key start stop [WITHSCORES]命令可实现分页，时间复杂度为O(log(N)+M)，在数据量大，查询比较耗时，可大大提高web的性能。 Pub/Sub – 发布 / 订阅发布订阅模式通过发布和订阅发送和接收消息，例如A和B订阅(subscribe)了频道news.it，这时候C向改频道发送(publish)一条信息hello，这时候A和B会收到这条消息，这就是最简单的发布订阅模式，A和B也可以订阅别的频道，可以接受来自不同频道的信息，注意这里的A和B是长连接，PUBSUB CHANNELS命令可查看当前活跃的频道。这个功能最典型应用就是IM系统，广播等场景，但是redis发布和订阅没有确认的过程，消息发出就没了，不管有没有收到，在实际场景中可能会选择别的方案。","categories":[],"tags":[]},{"title":"","slug":"进程间通信","date":"2018-02-01T11:38:26.771Z","updated":"2018-02-02T12:18:08.139Z","comments":true,"path":"2018/02/01/进程间通信/","link":"","permalink":"https://meetmax.github.io/2018/02/01/进程间通信/","excerpt":"","text":"Unix进程间通信(IPC)IPC概念: 进程间通信（IPC，Inter-Process Communication），指至少两个进程或线程间传送数据或信号的一些技术或方法。进程是计算机系统分配资源的最小单位(严格说来是线程)。每个进程都有自己的一部分独立的系统资源，彼此是隔离的。为了能使不同的进程互相访问资源并进行协调工作，才有了进程间通信。举一个典型的例子，使用进程间通信的两个应用可以被分类为客户端和服务器（见主从式架构），客户端进程请求数据，服务端回复客户端的数据请求。有一些应用本身既是服务器又是客户端，这在分布式计算中，时常可以见到。这些进程可以运行在同一计算机上或网络连接的不同计算机上。 进程间通信技术包括消息传递、同步、共享内存和远程过程调用。IPC是一种标准的Unix通信机制。 使用IPC 的理由： 信息共享：Web服务器，通过网页浏览器使用进程间通信来共享web文件（网页等）和多媒体； 加速：维基百科使用通过进程间通信进行交流的多服务器来满足用户的请求； 模块化; 私有权分离. 与直接共享内存地址空间的多线程编程相比，IPC的缺点：[1] 采用了某种形式的内核开销，降低了性能; 几乎大部分IPC都不是程序设计的自然扩展，往往会大大地增加程序的复杂度。 一、管道1、特点： 管道是一种半双工的通信方式(即数据只能单向流动)，也有部分系统上实现了全双工的管道，出于程序可移植性考虑，建议使用半双工管道，全双工的通信可由其它方式实现，例如：消息队列，Unix域套接字。 管道分为两种，无名管道和有名管道。 无名管道： 最早出现的管道是没有名字的，因此只能用于父子进程间通信，父进程通过fork()系统调用创建一个子进程，然后通过管道通信。 有名管道(FIFO): 有名管道也叫FIFO，由于磁盘中存在实际的管道文件，前者没有，所以叫有名管道。FIFO的意思是(first in ,first out)，先进先出。FIFO是一个(单向的)半双工数据流，不同于普通管道的是，每个FIFO都有一个对应文件的路径名与之关联，因此它能完成多个无亲缘关系进程之间的通信。 FIFO和无名管道的数据都存在内核的内存缓冲区中，大小一般为一页(4K)。不同的是，FIFO将内核缓冲区的数据映射到了实际的文件节点，可以在磁盘中看到对应的文件，所以叫有名管道，而无名管道在磁盘中没有对应文件，因此称无名管道。 无名管道通过&lt;unistd.h&gt;头文件中的pipe()创建，有名管道(FIFO)通过&lt;sys/stat.h&gt;中的mkfifo()创建。 管道通过read()和write()进行读写操作，管道内核缓冲区中的数据一旦被取走，管道中将不存在。当内核缓冲区满的时候，write()写操作将被阻塞，直到缓冲区有空闲再继续。同理，当缓冲区数据为空时，read()操作将阻塞，直到有新数据时再返回。 当进程终止时，管道就完全被删除了。 ###无名管道 1、过程 创建管道 12#include &lt;unistd.h&gt;pipe(int fd[2]) 通过fork()创建子进程 123// 返回值 &gt;=0:成功 &lt;0:错误// 如果是父进程则返回子进程 id,子进程则返回 0fork() read()和write()读写缓冲区的数据 2、例子 pipe.c 12345678910111213141516171819202122232425#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;int main()&#123; int fd[2]; // 管道描述符 pid_t pid; // 进程id char buff[20]; // 缓冲区长度 if(pipe(fd) &lt; 0)&#123; printf(\"创建管道失败\\n\"); &#125; pid = fork(); // 创建子进程 if(pid &lt; 0)&#123; printf(\"fork()失败\\n\"); &#125;else if (pid &gt; 0)&#123; // 大于0为主进程 close(fd[0]); // 关闭主进程读端 write(fd[1],\"hello world\\n\",12); &#125;else&#123; // 小于0为子进程 close(fd[1]); // 关闭子进程写端 sleep(2); read(fd[0], buff, 20); printf(\"读到的数据：%s\\n\", buff); &#125; return 0;&#125; 有名管道FIFO 1、过程 按以下示例，先运行read_fifo.c，创建管道文件(注意: 此时管道文件必须不存在，否则会出错)。 因为此时管道中还没有数据，read()处于阻塞状态，等待数据。 再运行write_fifo.c，向管道中写入数据，此时read()打印write_fifo.c写入的数据。 2、例子 read_fifo.c 1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;time.h&gt;#include &lt;sys/stat.h&gt;int main()&#123; int fd,len; char buff[1024]; //管道缓冲区大小 if(mkfifo(\"/Users/meetmax/CWork/fifo1\", 0666) &lt; 0) &#123; // 创建FIFO管道,此时`fif01`文件必须不存在，否则报错 perror(\"Create FIFO Failed\"); exit(1); &#125; if((fd = open(\"/Users/meetmax/CWork/fifo1\", O_RDONLY)) &lt; 0) &#123; // 以只读模式打开FIFO，和打开普通文件一样 perror(\"Open FIFO Failed\"); exit(1); &#125; // 如果管道中有数据，读取FIFO管道 while((len = read(fd, buff, 1024)) &gt; 0) printf(\"Read message: %s\", buff); close(fd); // 关闭FIFO文件 return 0;&#125; write_fifo.c 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt; // exit#include&lt;fcntl.h&gt; // O_WRONLY#include&lt;sys/stat.h&gt;#include&lt;time.h&gt; // time#include &lt;time.h&gt;int main()&#123; int fd; int n, i; char buf[1024]; time_t tp; printf(\"I am %d process.\\n\", getpid()); // 说明进程ID if((fd = open(\"/Users/meetmax/CWork/fifo1\", O_WRONLY)) &lt; 0) // 以写打开一个FIFO &#123; perror(\"Open FIFO Failed\"); exit(1); &#125; for(i=0; i&lt;10; ++i) &#123; time(&amp;tp); // 取系统当前时间 n=sprintf(buf,\"Process %d's time is %s\",getpid(),ctime(&amp;tp)); printf(\"Send message: %s\", buf); // 打印 if(write(fd, buf, n+1) &lt; 0) // 写入到FIFO中 &#123; perror(\"Write FIFO Failed\"); close(fd); exit(1); &#125; sleep(1); // 休眠1秒 &#125; close(fd); // 关闭FIFO文件 return 0;&#125; XIS IPC(基于System V 的IPC函数)除管道外，还有3种IPC的进程间的通信，分别为：消息队列、信号量和共享内存。这3个IPC有两种实现方式，分别为基于System V和POSIX的进程间通信。 维基百科 System V UNIX系统五[来源请求]（英语：UNIX System V），是Unix操作系统众多版本中的一支。它最初由AT&amp;T开发，在1983年第一次发布，因此也被称为AT&amp;T System V。 POSIX 可移植操作系统接口（英语：Portable Operating System Interface，缩写为POSIX），是IEEE为要在各种UNIX操作系统上运行软件，而定义API的一系列互相关联的标准的总称，其正式称呼为IEEE Std 1003，而国际标准名称为ISO/IEC 9945。 System V 出现比 POSIX 要早，可以说POSIX是对System V的改进，POSIX API使用比前者更加简单高效，但是为什么两者仍然同时存在呢？还是一个移植性的问题，虽然现在新的程序都基于POSIX标准，但是仍然有很多旧的程序使用了基于System V的IPC，因此两者都保留了。本文的IPC基于System V的IPC函数。 二、消息队列1、特点 消息队列是消息的链表，存储在内核中，由消息队列标识符标识。 消息队列是随内核持续的，进程终止时，消息队列及其内容不会被删除，除非内核重启或者调用msgctl()显式的删除消息队列。 消息队列没有维护引用计数器(打开文件有这种计数器)，所以队列被删除后，仍在使用该队列的进程会出错返回。 2、过程 先定义消息队列结构struct msg_form，每条消息都包含： 消息队列类型：long类型的mtype 消息数据：char *类型的字符串 通过文件的路径名和项目ID(0~255之间)，调用ftok()获取IPC，获取key值。创建XSI IPC结构都应指定一个键，这个键的数据类型是系统数据类型key_t，通常在头文件&lt;sys/types.h&gt;中定义。 接着调用msgget()函数，使用key作为其中一个参数，由内核将key变成IPC的标识符，在这里就是消息队列ID。 拿到IPC标识符后，通过msgsnd()和msgrcv()分别发送和接收消息。 3、示例 msg_client.c 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/msg.h&gt;#include &lt;unistd.h&gt;#define MSG_FILE \"/Users/meetmax/CWork/msg_file\"// 消息结构struct msg_form &#123; long mtype; char mtext[256];&#125;;int main()&#123; int msqid; // 消息队列id key_t key; // 键值 struct msg_form msg; //获取key值 if((key = ftok(MSG_FILE,100)) &lt; 0)&#123; perror(\"获取key值失败\\n\"); exit(0); &#125; printf(\"key 值为： %d\",key); if((msqid = msgget(key,IPC_CREAT|0777)) &lt; 0)&#123; perror(\"获取消息队列失败\"); exit(0); &#125; printf(\"消息队列id: %d \\n\",msqid); printf(\"进程id: %d \\n\",getpid()); msg.mtype = 888; // 设置消息类型 sprintf(msg.mtext,\"hello,I'm client %d\\n\",getpid()); msgsnd(msqid,&amp;msg,sizeof(msg.mtext),0); // 获取777类型的消息 msgrcv(msqid, &amp;msg, 256, 999, 0); printf(\"Client: receive msg.mtext is: %s.\\n\", msg.mtext); printf(\"Client: receive msg.mtype is: %ld.\\n\", msg.mtype); return 0;&#125; msg_server.c 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/msg.h&gt;#include &lt;unistd.h&gt;#define MSG_FILE \"/Users/meetmax/CWork/msg_file\"struct msg_form&#123; long mtype; char mtext[256];&#125;;int main()&#123; int msqid; key_t key; struct msg_form msg; //获取key值 if((key = ftok(MSG_FILE,100)) &lt; 0)&#123; perror(\"获取key失败\"); exit(1); &#125; //打印key值 printf(\"key的值为 %d \\n\",key); //根据key值创建消息队列 if((msqid = msgget(key,IPC_CREAT|0777)) &lt; 0)&#123; perror(\"创建消息队列失败\"); exit(1); &#125; printf(\"消息队列id为 : %d \\n\",msqid); printf(\"进程id为 : %d \\n\",getpid()); while(1) &#123; //接受888类型的消息 msgrcv(msqid,&amp;msg,256,888,0); printf(\"Server:receive msg.mtext: %s \\n\",msg.mtext); printf(\"Server:receive msg.xxx: %ld \\n\",msg.mtype); msg.mtype = 999; sprintf(msg.mtext,\"hello I'm server: %d \\n\",getpid()); //发送消息 msgsnd(msqid,&amp;msg,sizeof(msg.mtext),0); &#125; return 0;&#125; 三、信号量1、特点 信号量类似锁机制，能够使临界区内的资源在某一时刻只能被一个进程访问。临界区是指多个进程或线程共享的内存空间，在访问临界区的时候，多个进程操作同一个资源，此时就存在竞态条件，通常在两个进程对同一个资源写操作时，会产生结果不一致的问题，因为我们不知道系统进程何时切换，这种情况也很难复现和调试。必须有一种机制来保证在同一时刻只能有一个进程访问临界区，信号量就提供了这种机制。 信号量是一种特殊的变量，程序对它的访问都是原子操作，所谓原子操作，即是指不可被中断的操作，要实现原子操作单纯软件是不够的。虽然也能实现，但是效率很低，信号量是一种和硬件紧密结合的机制，它不会被系统进程切换和中断操作打断。本文以二值信号量为例子，二值信号量能实现互斥锁的功能，保证同一时间只能一个进程访问资源。 信号量的P,V操作 来自维基百科 计数信号量具备两种操作动作，之前称为 V（又称signal()）与 P（wait()）。 V操作会增加信号量 S的数值，P操作会减少它。 运作方式： 初始化，给与它一个非负数的整数值。 运行 P（wait()），信号量S的值将被减少。企图进入临界区块的进程，需要先运行 P（wait()）。当信号量S减为负值时，进程会被挡住，不能继续；当信号量S不为负值时，进程可以获准进入临界区块。 运行 V（又称signal()），信号量S的值会被增加。结束离开临界区块的进程，将会运行 V（又称signal()）。当信号量S不为负值时，先前被挡住的其他进程，将可获准进入临界区块。 2、过程 获取key值(同消息队列) 获取信号量ID(同消息队列) semctl()函数初始化信号量 fork()子进程 执行P,V操作 3、例子sem.c 二值信号量 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/sem.h&gt; // 信号量函数库#include &lt;unistd.h&gt;#define SEM_FILE \"/Users/meetmax/CWork/sem_file\" // 信号量文件union sem_union //信号量联合&#123; int val; struct semid_ds *buf; unsigned short *array;&#125;;//初始化信号量int init_sem(int sem_id,int val)&#123; union sem_union tmp; tmp.val = val; if((semctl(sem_id,0,SETVAL,tmp)) == -1) &#123; perror(\"初始化信号量失败\"); return -1; &#125; return 0;&#125;/** * P操作 * 信号量大于0时执行 -1 操作，获取资源 * 若信号量 &lt;= 0 则挂起等待*/int sem_p(int sem_id)&#123; struct sembuf sbuf; sbuf.sem_num = 0; sbuf.sem_op = -1; sbuf.sem_flg = SEM_UNDO; if(semop(sem_id,&amp;sbuf,1) == -1) &#123; perror(\"p操作失败\"); return -1; &#125; return 0;&#125;/** * V操作 * 信号量 &lt;= 0时执行，+1操作，释放资源 * 若信号量 &gt; 0 时挂起等待 */int sem_v(int sem_id)&#123; struct sembuf sbuf; sbuf.sem_num = 0; sbuf.sem_op = 1; sbuf.sem_flg = SEM_UNDO; if(semop(sem_id,&amp;sbuf,1) == -1) &#123; perror(\"V操作失败\"); return -1; &#125; return 0;&#125;//删除信号量int sem_del(int sem_id)&#123; union sem_union tmp; if(semctl(sem_id,0,IPC_RMID,tmp) == -1) &#123; perror(\"删除信号量失败\"); return -1; &#125; return 0;&#125;int main()&#123; int sem_id; key_t key; pid_t pid; //获取key值 if((key = ftok(SEM_FILE,100)) == -1) &#123; perror(\"获取key值失败\"); exit(1); &#125; //获取信号量id if((sem_id = semget(key,1,IPC_CREAT|0666)) == -1) &#123; perror(\"信号量id获取失败\"); exit(1); &#125; //初始化信号量 init_sem(sem_id,0); //fork进程 if((pid = fork()) == -1) &#123; perror(\"进程fork失败\"); exit(1); &#125;else if(pid == 0)&#123; //子进程 printf(\"我是子进程：%d \\n\",getpid()); sleep(2); sem_v(sem_id); &#125;else if(pid &gt; 0)&#123; //父进程 sem_p(sem_id); printf(\"我是父进程：%d \\n\",getpid()); sem_v(sem_id); sem_del(sem_id); &#125; return 0;&#125; 四、共享内存1、特点概念 顾名思义，共享内存就是允许两个不相关的进程访问同一个逻辑内存。共享内存是在两个正在运行的进程之间共享和传递数据的一种非常有效的方式。不同进程之间共享的内存通常安排为同一段物理内存。进程可以将同一段共享内存连接到它们自己的地址空间中，所有进程都可以访问共享内存中的地址，就好像它们是由用C语言函数malloc分配的内存一样。而如果某个进程向共享内存写入数据，所做的改动将立即影响到可以访问同一段共享内存的任何其他进程。 2、过程 ftko()获取key值(同消息队列) 用shmget()函数获取共享内存ID 进程通过shmat()函数连接共享内存 访问共享内存 3、示例shm_server.c 读数据 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/shm.h&gt;#include &lt;string.h&gt;#define SHM_FILE \"/Users/meetmax/CWork/shm_file\"int main()&#123; int shm_id; key_t key; char * shm; struct shmid_ds buf; // 获取key if((key = ftok(SHM_FILE,100)) == -1) &#123; perror(\"获取key失败\"); exit(0); &#125; // 获取共享内存描述符ID if((shm_id = shmget(key,512,IPC_CREAT|0666)) == -1) &#123; perror(\"获取共享内存id失败\"); exit(0); &#125; // 连接共享内存 if((int)(shm = (char *)shmat(shm_id,0,0)) == -1) &#123; perror(\"连接共享内存失败\"); exit(1); &#125; printf(\"开始接收数据\\n\"); // 开始忙等，接收数据 while(1) &#123; if(strlen(shm) &gt; 0)&#123; printf(\"收到数据：%s \\n\",shm); sprintf(shm,\"\"); &#125; if(strcmp(shm,\"r\") == 0)&#123; printf(\"已退出\\n\"); break; &#125; &#125; // 删除共享内存 shmctl(shm_id,IPC_RMID,&amp;buf); return 0;&#125; sem_client.c 写入数据 1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/shm.h&gt;#define SHM_FILE \"/Users/meetmax/CWork/shm_file\"int main()&#123; int shm_id; key_t key; char * shm; // 获取key if((key = ftok(SHM_FILE,100)) == -1) &#123; perror(\"获取key失败\"); exit(0); &#125; // 获取共享内存id if((shm_id = shmget(key,512,IPC_CREAT|0666)) == -1) &#123; perror(\"获取共享内存id失败\"); exit(0); &#125; // 连接共享内存，若不存在则创建 if((int)(shm = (char *)shmat(shm_id,0,0)) == -1) &#123; perror(\"连接共享内存失败\"); exit(1); &#125; printf(\"请输入：\"); scanf(\"%s\",shm); // 写入数据到共享内存 shmdt(shm); // 断开连接 return 0;&#125; 参考 《UNIX环境高级编程》 《UNIX网络编程：卷2》 部分来自互联网","categories":[],"tags":[]},{"title":"","slug":"Mysql之Explain浅析","date":"2018-01-20T06:13:41.541Z","updated":"2018-01-22T16:06:17.531Z","comments":true,"path":"2018/01/20/Mysql之Explain浅析/","link":"","permalink":"https://meetmax.github.io/2018/01/20/Mysql之Explain浅析/","excerpt":"","text":"​ 在工作中，经常会碰到一些慢查询，Explain 语句可以帮我们更详细的了解MySQL查询的执行计划，用法也很简单Explain 后面跟上SELECT语句即可。执行完之后，会显示一行有多个列的记录，可能很多人和我一样，对EXPLAIN里面字段的含义，并没有深入的去了解过，处于一知半解的状态，只知道一些最常见的。 ​ 下面我根据MySQL官方文档，查阅了很多资料，再结合我自己的理解，对EXPLAIN的字段和值做了详细的描述，在总结过程中，也发现了自己的很多知识漏洞，很多时候，我总是会想当然的认为，这个就是对的，并没有严密逻辑验证，主要是懒的思考，正所谓好记性不如烂笔头，写的过程也是对自己知识点掌握程度的批判和考验。 关于EXPLAIN​ EXPLAIN返回一行记录，通过Explain可以获取到很多信息，如：不同表的查询顺序，查询用了哪些表，能使用哪些索引以及真正用到了哪些索引，用了哪种连接类型，是否有临时表和文件排序等。这些因素对查询的效率有直接的相关，想要使查询更高效，需要对这些条件做一个好的优化。 ​ EXPLAIN有12个字段，每个字段对查询优化的权重比不一样，也就是说并不是所有字段都很重要。type,key,Extra字段相对其它字段来说，对查询效率的影响更大，优化查询的时候，先把注意力放到这些字段会比其它字段来得更加直接有效，下面开始具体内容。 EXPLAIN语法以user_info表为例： 1explain select * from `user_info` where uid = 5 结果： id select_type table partitions type possible_keys key key_len ref rows filtered Extra 1 SIMPLE user_info NULL const PRIMARY PRIMARY 8 const 1 100.00 NULL EXPLAIN字段说明注： 标注星号的字段为重点 id：SELECT语句的标识符，代表SELECT查询在整个查询中的序号。这个值也可能为NULL，如果这一行是UNION的结果。 select_type:SELECT查询的类型，该类型的值有11种类型。例如，示例中的值为SIMPLE，表示该查询是一个简单的查询（即：没有子查询和UNION）。 ####table: 大多数情况下表示输出行所引用的表名，它也可能是下列值之一： partitions:只对分区表有意义。意思是查询所匹配到的分区，如果该表为非分区表，则它的值为NULL。 *type:查询的join类型，注意单表查询也被当做join的特例，并不一定要两张表。连接类型详情下面会详细介绍。 possible_key:possible_key列是指，在查询中能够被MySQL用到的索引，但在实际情况中，不一定会被全部用到，这取决于MySQL优化器的选择，假设possible_key有A,B,C,3个索引，优化器经过分析认为A索引不需要用，那么实际执行的时候只会用到B,C索引。实际应用中，该列经常帮我们对SQL查询进行优化，如果它的值为NULL，说明没有能被用到的索引，这种情况下，需要调整SQL语句和优化表的索引。 *key:查询中实际用到的索引，要注意，该列的值可能包含possible_key列中没有出现的索引，当查询满足覆盖索引的条件时，possible_keys列为NULL，索引仅在key列显示，MySQL只需要扫描索引树，不用到实际的数据行检索即可得到结果，查询会更高效，Extra列显示USING INDEX，则证明使用了覆盖索引。 也可以通过FORCE INDEX,USE INDEX或IGNORE INDEX来强制使用或忽略possible_key列中的索引。 覆盖索引概念： 如果索引包含所有满足查询需要的数据的索引成为覆盖索引(Covering Index)。 假设有一个user表，假设索引A包含了col1,col2,col3三个字段，criteria为标准条件。 12Query 1:select * from user where criteria Query 1使用了索引查询，获取到数据行的主键，但是仍然需要根据主键值扫描实际的数据行。 12Query 2:select `col1`,`col2` where criteria Query 2中，索引A已经包含了它需的字段，也就是说Query 2不用再去实际的数据行获取数据了，只要扫描完索引树就行了，这样就省了一个步骤，索引树往往比实际的数据表小，所以效率很高，这就是覆盖索引。 key_len:实际用到的索引字段长度，越短越好。 ref:ref列显示哪个列或者常数和索引比较筛选出结果。 rows:rows列表示MySQL认为执行查询必须检查的行数，对Innodb表来说，这是一个预估值，可能并不是确切的值。 filtered:​ filtered的意思是，首先MySQL利用索引，例如，用range范围扫描出符合的行，如果扫描符合条件的估计值是100行，rows显示估计的值就是100，这一步是存储引擎根据索引筛选后的值，然后在Server层根据其余的WHERE条件过滤。 ​ 被过滤器过之后，符合条件的还剩下20行，也就是剩下20%，20%就是filtered中的值。很显然，直接在存储引擎层筛选出20行比先筛选出100行再过滤要更好，通常情况下，filtered的值越大可能意味着索引越好。 ​ 另一方面看，你也可以完全忽略filtered，因为这个值在大多数情况下只是一个不准确的估计，应该把注意力放到优化其它更有用的字段上，尤其是type,key,Extra。例如：尽量避免filesort排序，使用索引排序。或者有一个更好的type值，对性能的提升是非常巨大的，这种情况，即使filtered的值低也没关系。假设一个查询A， type=all,filtered=0.1%。那么首要先关注type字段，可通过添加索引来优化，可以先不管filtered。 ​ 所以对这个值不需要太认真，即使100%也不意味着索引一定好，反过来也不一定说明索引差，type比它更能说明索引的好坏。 *Extra:这个列包含Mysql解决查询的详细信息，详情见下方。 EXPLAIN字段值说明：select_type: select_type 值 描述 SIMPLE 简单的SELECT查询（没有UNION和子查询） PRIMARY 一个需要union操作或者含有子查询的select，位于最外层的单位查询的select_type即为primary。且只有一个 UNION UNION连接的select查询，除了第一个表外，第二个及以后的表select_type都是union DEPENDENT UNION 与union一样，出现在union 或union all语句中，但是这个查询要受到外部查询的影响 UNION RESULT UNION之后的结果集 SUBQUERY 除了from字句中包含的子查询外，其他地方出现的子查询都可能是subquery DEPENDENT SUBQUERY 与dependent union类似，表示这个subquery的查询要受到外部表查询的影响 DERIVED FROM字句中出现的子查询。语法：SELECT ... FROM (subquery) [AS] tbl_name ... MATERIALIZED 被物化的子查询 UNCACHEABLE SUBQUERY 对于外层的主表，子查询不可被物化，每次都需要计算（耗时操作） UNCACHEABLE UNION UNION操作中，内层的不可被物化的子查询（类似于UNCACHEABLE SUBQUERY） 通过 物化 优化子查询的原理： ​ 优化器使用物化的方式能让子查询更高效的执行，类似缓存技术，把第一次查询的结果存起来，避免多次的耗时操作，同时也有它自身的限制，不是所有子查询都能被物化的。物化技术把子查询产生的结果放在一个临时表中，如果数据量小的话，通常是在内存中完成，数据大的时候就降级到磁盘进行，速度也会慢很多。首先，MySQL得到子查询的结果，然后把结果放到临时表中，在随后的任何时间，当需要这个结果时，MySQ就再次引用这个临时表，不需要再执行计算了。优化器可能会使用哈希索引（复杂度为O(1)，很快）来快速且低成本的查找表，这个索引是唯一的，避免了重复，能使表更小。 12SELECT * FROM t1WHERE t1.a IN (SELECT t2.b FROM t2 WHERE where_condition); type（连接类型）： system 当表只有一行数据的时候，这是const连接类型的特例。 const 表中最多只有一行匹配，在查询开始时被读取。因为只有一行，该行中列的值可以被优化器的其余部分视为常量。const表非常快，因为他们仅被读取一次。将PRIMARY KEY 或 UNIQUE INDEX索引和常量值比较时,会使用const。例如： 1234SELECT * FROM tbl_name WHERE primary_key=1;SELECT * FROM tbl_nameWHERE primary_key_part1=1 AND primary_key_part2=2; eq_ref 假设A JOIN B，B表读取A表的各个行组合的一行时，通过B表的PRIMARY KEY或UNIQUE NOT NULL索引列连接时，优化器会使用eq_ref类型，这是除了system和const之外最快的JOIN类型。 举例说明： 表tableA,有（id,text）字段，id为PRIMARY KEY,A表数据为： | id | text || —- | —– || 1 | HELLO || 2 | THANK | 表tableB有（id,text）字段，id为PRIMARY KEY,B表数据为： | id | text || —- | —– || 1 | WORLD || 2 | YOU | 现在通过JOIN将两个表关联起来 123SELECT A.text,B.text FROM tableA AS A,tableB as B WHERE A.id=B.id 这个连表查询是非常快的，因为在A表中扫描的每一行，在B表中也仅一行满足条件。 ref ​ A JOIN C时，A表中的每一行不是唯一的，对单表查询也一样，有多个满足条件的行，查询的KEY是单个索引或复合索引的最左前缀(不是唯一索引和主键)，也就是说C表的id是一个非唯一索引。这种情况下，优化器会使用ref优化，如果只有少部分行(rows)满足条件，这个连接类型(join type)是很好的。ref用于索引的比较操作，注意：仅对于=,&lt;=&gt; 操作有效，对于&gt;,&lt;,BETWEEN,IN的范围操作优化器可能会使用range类型(见下方),也可能是ALL全表扫描。 举例说明： 现在有tableC，id为索引，不唯一。数据为： | id (非唯一索引) | text || ———- | ——– || 1 | HANGZHOU || 1 | SHANGHAI | 现在通过LEFT JOIN将A和C关联起来: 123SELECT A.text,C.text FROM `tableA` AS A LEFT JOIN `tableC` AS C ON A.id=C.id 这个JOIN不像之前的那么快，因为在表A中扫描的每一行，在表C中可能有很多行满足条件，C的id不是唯一索引。 fulltext 使用了全文索引，Innodb不支持全文索引。 ref_or_null 如果一个查询的WHERE子句中包含colA IS NULL的条件，但是colA已经被声明为NOT NULL，此时优化器会使用ref_or_null类型。 12SELECT * FROM ref_tableWHERE key_column=expr OR key_column IS NULL; index_merge ​ 在MYSQL5.0之前是没有索引合并功能的，假设A表有3个单独的索引col1 ,col2,col3，然后执行如下SQL: 1SELECT * FROM A WHERE col1=1 AND col2=2 AND col3=3 实际查询中只有一个索引能被用到，这种情况，只能通过建立复合索引(col1,col2,col3)才能在索引中用到所有字段。 ​ 5.0之后有了索引合并，当检索数据行时出现多个范围扫描条件时，在满足索引合并前提条件时(单个索引覆盖WHERE条件的字段)，MySQL优化器可能会使用索引合并(不一定)，首先分别对多个索引进行扫描，然后合并来自单个表的扫描结果，它不能合并多个表的扫描结果，合并的方式有3种： unions：索引取并集 intersections：索引取交集 Sort-Union:先对取出的数据按主键排序，再取并集 索引合并条件： WHERE子句中的范围条件，WHERE中出现字段必须被索引覆盖，如果colA没添加索引，则只会对colB和colC进行索引合并，Extra字段显示Using intersect(colB,colC);，type为index_merge，则说明用到了索引合并。 1WHERE colA = const1 AND colB = const2 AND colC = const3 Innodb表中的主键的任何范围条件，&gt;,&lt;,&lt;&gt;等。 12SELECT * FROM innodb_table WHERE primary_key &lt; 10 AND key_col1 = 20; ​ 满足了条件，MYSQL会选择索引行数最少的字段对索引结果进行合并，最终使用哪个索引字段来合并也不一定，也可能不使用合并，这取决于优化器，如果优化器认为没必要使用索引合并优化，就会使用其它优化，也许会选择type 为range或更高效的ref的优化。 ​ 当优化器决定使用索引合并优化，如果WHERE条件用AND连接，优化器会使用INTERSECTIONS合并算法，对多个索引扫描的结果取交集。如果用OR连接，优化器会选择UNIONS或SORT-UNIONS合并算法，对多个索引扫描的结果取合集，SORT-UNIONS和UNIONS的主要区别是，前者在扫描完数据时，需要先对数据按主键排序，再取它们的合集。 ​ 在WHERE子句中使用AND时，使用复合索引比索引合并更高效，因为复合索引只用一个索引筛选，没有匹配合并的过程，这个过程节省了很多时间。 ​ 在使用OR时，复合索引是不起作用的，这种情况下，使用UNIONS索引合并效果更好。如果不想使用某种索引合并，也可以选择关闭。可通过optimzer_switch系统变量查看各个索引合并的开启状况。如下： 1SELECT @@optimizer_switch 索引合并算法的默认都是开启的，可以通过关闭某个合并算法。例如： 1SET optimizer_switch = &apos;index_merge_intersection=off&apos; unique_subquery 这种类型是eq_ref类型在子查询中的替代类型。例如 12SELECT * FROM A WHEREvalue IN (SELECT id FROM B WHERE some_expr) B表中的id在A表中有唯一对应的记录。 range ​ 在WHERE子句中，执行&gt;,&lt;,&lt;&gt;,=,BETWEEN,IN() 等操作时，MySQL可能会(不一定)使用range类型，Explain中key列的值就是实际用到的索引，key_len是它们中最长的索引的长度。如果优化器认为使用索引筛选没有全表扫描来得及，例如：条件筛选后的行占全表的50%以上，即使有索引可用，优化器也会选择全表扫描，即type=ALL。 ​ 为什么呢？解释这个问题之前，需要先了解几个概念。对Innodb表来说，每个表都有一个聚簇索引，InnoDB的聚簇索引实际上在同一个结构中保存了B-Tree索引和数据行信息。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。二级索引存储的是记录的主键，而不是数据存储的地址，索引数据和存储数据是分离的，唯一索引、普通索引、前缀索引等都是二级索引。实际上，InnoDB在查询任何数据时，最后都是通过主键来查询的。首先我们根据索引条件在索引树上扫描出对应的主键值。然后根据这个值去聚簇索引总超找到对应的行(如果是覆盖索引则省略这一步)。 ​ 在某些情况下，索引条件扫描出的数据行非常大，可能占了全表的50%，此时再根据主键找到对应的数据块是不划算。主键的BTree查找属于文件的随机搜索，但是如果随机搜索文件数据的目的是为了查找一半的数据，这并不是最优化的，只要对数据文件进行大量的顺序读写要更快，这种情况下，索引会被忽略。 index ​ index类型和ALL类型几乎相同。有两种情况： 若SELECT中列全部被索引覆盖，所需要的数据可以直接在索引中读取，MySQL只需对索引树进行扫描，这通常比扫描实际数据行要快，因为索引树通常比数据表更小，这种情况下，Extran的值会显示USING INDEX。 使用索引中读取的主键值，按索引顺序对全表进行扫描，此时Extra中没有USING INDEX。 ALL 对表的每一行进行扫描，这是最糟糕的情况。一般，你可以通过添加索引来避免这种情况发生。 Extra列值的含义:​ Extra列包含了MySQL处理查询的一些额外信息，下面的列出了Extra中可能出现的值，如果你想让查询尽可能的快，应该注意下Extra字段中是否出现了using filesort 和using temporary。下面只列除了在实际应用中经常会出现，相对比较重要的一部分，若描述的不够详细，可查看MySQL官方文档。 const row not found 1SELECT * FROM A 如果A表为空，则会出现改值。 DISTINCT mysql在寻找不同的值，当它找到第一个匹配的行之后，就停止搜索更多的行了。例子： no matching row in const table 用唯一索引或者主键查询时，没有匹配到的数据。 Not exists MySQL优化了LEFT JOIN，一旦它找到了匹配LEFT JOIN标准的行，就不再搜索了，。例如： 12SELECT * FROM t1 LEFT JOIN t2 ON t1.id=t2.id WHERE t2.id IS NULL; Using filesort ​ 这个值表示，MySQL必须对检索到的结果进行额外的排序。排序是按照连接类型遍历所有行并存储排序键和指向行的指针，以匹配满足where子句条件的所有行，然后对键进行排序，并按排序顺序检索行。根据不同情况，MySQL会选择不同的排序算法，在数据比较小的时候，MySQL会利用排序缓冲区作为优先级队列将结果在内存中排序，否则只能通过合并文件的方式合并，那会慢很多，排序缓冲区的大小取决于sort_buffer_size变量的大小。 ​ 总之，当看到filesort的时候就应该引起重视，通过优化索引来避免额外的文件排序，这对性能影响是很大的。 Using index 单个索引覆盖了SELECT的所有列（即：覆盖索引），不需要对实际的数据行进行扫描。 Using index condition ​ Index Condition Pushdown (ICP)是MySQL 5.6 版本中的新特性,是一种在存储引擎层使用索引过滤数据的一种优化方式。当关闭ICP时,index 仅仅是data access 的一种访问方式，存储引擎通过索引回表获取的数据会传递到MySQL Server 层进行where条件过滤。 ​ 当打开ICP时,如果部分where条件能使用索引中的字段,MySQL Server 会把这部分下推到引擎层,可以利用index过滤的where条件在存储引擎层进行数据过滤,而非将所有通过index access的结果传递到MySQL server层进行where过滤.优化效果:ICP能减少引擎层访问基表的次数和MySQL Server 访问存储引擎的次数,减少io次数，提高查询语句性能。 Using index for group-by 和USING INDEX很相似，区别是，当查询语句中含有DISTINCT和GROUP BY操作时，仅需访问索引树，不需要访问实际的表时，使用该优化。 Using sort_union(…),Using union(…),Using intersect(…)` 当查询产生索引合并时会显示该值，type为index_merge。 Using temporary 为了处理查询，MySQL必须建立一个临时表才能产生结果。典型的情况是，在使用GROUP BY和ORDER BY子句时，两者使用了不同的列会导致产生临时表。 Using where using where 是指使用WHERE或ON子句，MySQL Server层收到存储引擎返回的结果时，需要对结果再次过滤，不需要返回所有结果，注意LIMIT不算限制条款。如果没有用到索引using where只是说明，使用了顾虑条件过滤。 参考MySQL官方文档","categories":[],"tags":[]}]}