<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>meetmax.cn</title>
   
   <link>http://localhost:4000</link>
   <description>Stay Hungry , Stay Foolish</description>
   <language>en-uk</language>
   <managingEditor> </managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>Java学习笔记(四) - 类</title>
	  <link>//Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E5%9B%9B)-%E7%B1%BB</link>
	  <author></author>
	  <pubDate>2018-08-28T00:00:00+08:00</pubDate>
	  <guid>//Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E5%9B%9B)-%E7%B1%BB</guid>
	  <description><![CDATA[
	     <h2 id="声明类">声明类</h2>
<p>Java的类可以通过<code class="highlighter-rouge">class</code>关键词，<code class="highlighter-rouge">{}</code>大括号来声明，在<code class="highlighter-rouge">{}</code>大括号中间是类的<code class="highlighter-rouge">body</code>体，在<code class="highlighter-rouge">body</code>体内可声明成员变量、方法和构造函数等等。另外，也可以在<code class="highlighter-rouge">class</code>前面加上修饰符<code class="highlighter-rouge">private</code>或<code class="highlighter-rouge">public</code>，修饰符的作用是访问控制，前者说明该类是私有类，其它类不能访问它，后者是公开的，任何类都可以访问它，下面是公开类的声明示例。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Myclass</span> <span class="o">{</span>
	<span class="c1">// 这里可以声明成员变量</span>
	<span class="c1">// 方法、构造函数等</span>
<span class="o">}</span>
</code></pre></div></div>

<p>上面是一个简单类的声明，类还可通过关键词<code class="highlighter-rouge">extends</code>继承其它类，通过关键词<code class="highlighter-rouge">implements</code>继承多个接口，例如：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">MyClass</span> <span class="kd">extends</span> <span class="n">MySuperClass</span> <span class="kd">implements</span> <span class="n">YourInterface</span><span class="o">,</span><span class="n">YourInterface2</span> <span class="o">{</span>
    <span class="c1">// field, constructor, and</span>
    <span class="c1">// method declarations</span>
<span class="o">}</span>
</code></pre></div></div>

<p>通常，类的声明包含以下几个部分：</p>

<ol>
  <li>修饰符，例如<code class="highlighter-rouge">public</code>，<code class="highlighter-rouge">private</code>，<code class="highlighter-rouge">protected</code>等。</li>
  <li>类的名称，按照规范，类名首字母大写(非必须)，增加可读性</li>
  <li>可通过关键词<code class="highlighter-rouge">extends</code>继承<code class="highlighter-rouge">超类</code>，且只能继承一个<code class="highlighter-rouge">超类</code>，Java不支持多继承</li>
  <li>可通过关键词<code class="highlighter-rouge">implements</code>继承接口，Java接口支持多继承，接口之间用<code class="highlighter-rouge">,</code>逗号分隔。</li>
  <li>类的<code class="highlighter-rouge">body</code>体，在<code class="highlighter-rouge">{}</code>大括号之间。</li>
</ol>

<h2 id="声明成员变量">声明成员变量</h2>
<p>成员变量是指在类的内部，且不在<code class="highlighter-rouge">方法</code><code class="highlighter-rouge">块</code>内，且不是方法的参数，下面是声明成员变量的示例：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Myclass</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="n">String</span> <span class="n">hello</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>上面的代码中，<code class="highlighter-rouge">hello</code>就是一个公开的，<code class="highlighter-rouge">String</code>类型的成员变量，成员变量一般由以下3部分组成：</p>

<ol>
  <li>0或多个修饰符，例如<code class="highlighter-rouge">private</code>或<code class="highlighter-rouge">public</code></li>
  <li>字段类型</li>
  <li>字段名称</li>
</ol>

<h2 id="方法声明">方法声明</h2>

<p>下面是一个方法声明的例子：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Myclass</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kt">double</span> <span class="nf">calculateAnswer</span><span class="o">(</span><span class="kt">double</span> <span class="n">wingSpan</span><span class="o">,</span> <span class="kt">int</span> <span class="n">numberOfEngines</span><span class="o">,</span><span class="kt">double</span> <span class="n">length</span><span class="o">,</span> <span class="kt">double</span> <span class="n">grossTons</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">//do the calculation here</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>方法声明由以下6部分组成:</p>
<ol>
  <li>修饰符-例如<code class="highlighter-rouge">public</code>,<code class="highlighter-rouge">private</code></li>
  <li>返回值的类型，如果没有返回值则声明为<code class="highlighter-rouge">void</code></li>
  <li>方法名</li>
  <li>方法的参数，在<code class="highlighter-rouge">()</code>内声明，多个参数之间用<code class="highlighter-rouge">,</code>逗号隔开，如果没有参数，就是用空的<code class="highlighter-rouge">()</code></li>
  <li>一个异常列表</li>
  <li>方法的<code class="highlighter-rouge">body</code>，在<code class="highlighter-rouge">{}</code>之间包含了方法代码和局部变量等。</li>
</ol>

<h3 id="方法签名">方法签名</h3>
<p><strong>方法签名</strong> 包括方法名称和参数类型，在上面代码中，它的方法签名是</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">calculateAnswer</span><span class="o">(</span><span class="kt">double</span><span class="o">,</span> <span class="kt">int</span><span class="o">,</span> <span class="kt">double</span><span class="o">,</span> <span class="kt">double</span><span class="o">)</span>
</code></pre></div></div>

<h3 id="方法重载">方法重载</h3>
<p>在同一个类里可以有相同名称的方法，只要它们的方法签名不同，Java编译器可以根据方法签名判断出你要调用的具体方法，例如：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">DataArtist</span> <span class="o">{</span>
    <span class="o">...</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">draw</span><span class="o">(</span><span class="n">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="o">...</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">draw</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span>
        <span class="o">...</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">draw</span><span class="o">(</span><span class="kt">double</span> <span class="n">f</span><span class="o">)</span> <span class="o">{</span>
        <span class="o">...</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">draw</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">double</span> <span class="n">f</span><span class="o">)</span> <span class="o">{</span>
        <span class="o">...</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>上面代码中有4个名为<code class="highlighter-rouge">draw</code>的方法，在调用的时候，Java编译器可根据参数类型区分出调用的是哪个方法，在同一个类中不能声明具有相同名称、相同的参数数量和相同参数类型的方法，即使他们返回类型不一样，因为Java编译器无法识别出调用的是哪个方法。</p>

<h2 id="类的构造函数">类的构造函数</h2>
<p>每个类都包含构造函数，构造函数在创建对象时被调用，构造函数的声明和方法的声明很像，除了构造函数没有返回值，且函数名必须和类名一样。例如<code class="highlighter-rouge">Bicycle</code>类有一个构造函数</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="nf">Bicycle</span><span class="o">(</span><span class="kt">int</span> <span class="n">startCadence</span><span class="o">,</span> <span class="kt">int</span> <span class="n">startSpeed</span><span class="o">,</span> <span class="kt">int</span> <span class="n">startGear</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">gear</span> <span class="o">=</span> <span class="n">startGear</span><span class="o">;</span>
    <span class="n">cadence</span> <span class="o">=</span> <span class="n">startCadence</span><span class="o">;</span>
    <span class="n">speed</span> <span class="o">=</span> <span class="n">startSpeed</span><span class="o">;</span>
<span class="o">}</span><span class="kd">public</span> <span class="nf">Bicycle</span><span class="o">(</span><span class="kt">int</span> <span class="n">st</span>
</code></pre></div></div>

<p>可以通过<code class="highlighter-rouge">new</code>操作符创建<code class="highlighter-rouge">Bicycle</code>的对象，并初始化相关的字段。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Bicycle</span> <span class="n">myBike</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Bicycle</span><span class="o">(</span><span class="mi">30</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">8</span><span class="o">);</span>
</code></pre></div></div>

<p>和方法重载一样，一个类可以有多个构造函数，只要它们的方法签名不一样。例如，下面是一个无参数的构造函数</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="nf">Bicycle</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">gear</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
    <span class="n">cadence</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>
    <span class="n">speed</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="方法中的参数传递">方法中的参数传递</h2>
<p>在Java中数据分为2种类型即，原始数据类型和引用数据类型，数据在传递给方法时，2种数据类型的传递方式是不同的。</p>

<h3 id="原始数据类型的传递">原始数据类型的传递</h3>
<p>原始数据类型是按值传递的，它传递的是该数据的值的拷贝，什么意思呢？请看下面的代码，假设我把值<code class="highlighter-rouge">99.00</code>传给<code class="highlighter-rouge">computePayment</code>方法，方法在内部把我传入的值修改变成了100，但是这个修改仅仅在方法内部有效，方法到<code class="highlighter-rouge">return</code>就结束了，在方法外部，我的值还是<code class="highlighter-rouge">99.00</code>。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">double</span> <span class="nf">computePayment</span><span class="o">(</span><span class="kt">double</span> <span class="n">loanAmt</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">double</span> <span class="n">loanAmt</span> <span class="o">=</span> <span class="mf">100.0</span><span class="o">;</span>
    <span class="k">return</span> <span class="n">loanAmt</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<h3 id="引用类型的传递">引用类型的传递</h3>
<p>引用类型的数据是按引用传递的，它传递的是该数据的内存地址的引用。什么意思呢？下面的代码中，我通过调用<code class="highlighter-rouge">circle</code>对象的<code class="highlighter-rouge">setX</code>和<code class="highlighter-rouge">setY</code>方法，对它的成员变量<code class="highlighter-rouge">x</code>和<code class="highlighter-rouge">y</code>进行了修改，和值传递不同的是，它的修改是永久的，当方法运行结束，该修改仍然有效。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">moveCircle</span><span class="o">(</span><span class="n">Circle</span> <span class="n">circle</span><span class="o">,</span> <span class="kt">int</span> <span class="n">deltaX</span><span class="o">,</span> <span class="kt">int</span> <span class="n">deltaY</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// code to move origin of circle to x+deltaX, y+deltaY</span>
    <span class="n">circle</span><span class="o">.</span><span class="na">setX</span><span class="o">(</span><span class="n">circle</span><span class="o">.</span><span class="na">getX</span><span class="o">()</span> <span class="o">+</span> <span class="n">deltaX</span><span class="o">);</span>
    <span class="n">circle</span><span class="o">.</span><span class="na">setY</span><span class="o">(</span><span class="n">circle</span><span class="o">.</span><span class="na">getY</span><span class="o">()</span> <span class="o">+</span> <span class="n">deltaY</span><span class="o">);</span>
        
    <span class="c1">// code to assign a new reference to circle</span>
    <span class="n">circle</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Circle</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="参考">参考</h2>
<p><a href="https://docs.oracle.com/javase/tutorial/java/javaOO/arguments.html">The Java™ Tutorials</a></p>

	  ]]></description>
	</item>

	<item>
	  <title>Java学习笔记(三) - 表达式、语句和块</title>
	  <link>//Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%89)-%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E8%AF%AD%E5%8F%A5%E5%92%8C%E5%9D%97</link>
	  <author></author>
	  <pubDate>2018-08-28T00:00:00+08:00</pubDate>
	  <guid>//Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%89)-%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E8%AF%AD%E5%8F%A5%E5%92%8C%E5%9D%97</guid>
	  <description><![CDATA[
	     <h2 id="表达式">表达式</h2>
<p>表达式是由变量、操作符和方法调用组成的一个就算过程，它一定有单个的返回值，下面是表达式的例子：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">code</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>

<span class="k">if</span> <span class="o">(</span><span class="n">value1</span> <span class="o">==</span> <span class="n">value2</span><span class="o">)</span> 
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"value1 == value2"</span><span class="o">);</span>
</code></pre></div></div>

<p>在上面的示例中，<code class="highlighter-rouge">code = 1</code>是一个表达式，它返回一个<code class="highlighter-rouge">int</code>类型的值，表达式的返回值也可以是其它类型，<code class="highlighter-rouge">value1 == value2</code>是一个返回布尔值的表达式。Java语言也可以通过各种较小的表达式构成符合表达式，如下所示：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">1</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="mi">3</span>
</code></pre></div></div>

<h2 id="语句">语句</h2>
<p>通俗的讲语句就是自然语言中的句子。一条一句是一个完整的执行单元，表达是是语句的一部分，下面这些类型的表达式，在其后面加上分号就变成语句了。</p>

<ul>
  <li>
    <p>赋值表达式</p>
  </li>
  <li>
    <p>使用了<code class="highlighter-rouge">++</code>或者<code class="highlighter-rouge">--</code>的表达式</p>
  </li>
  <li>
    <p>方法调用</p>
  </li>
  <li>
    <p>对象的创建</p>
  </li>
</ul>

<p>这些语句被称为表达式语句，下面是一些表达式语句的例子。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// assignment statement</span>
<span class="n">aValue</span> <span class="o">=</span> <span class="mf">8933.234</span><span class="o">;</span>
<span class="c1">// increment statement</span>
<span class="n">aValue</span><span class="o">++;</span>
<span class="c1">// method invocation statement</span>
<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Hello World!"</span><span class="o">);</span>
<span class="c1">// object creation statement</span>
<span class="n">Bicycle</span> <span class="n">myBike</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Bicycle</span><span class="o">();</span>
</code></pre></div></div>

<p>另外，语句可以分为<code class="highlighter-rouge">声明语句</code>和<code class="highlighter-rouge">控制流语句</code>，上面的例子是<code class="highlighter-rouge">声明语句</code>，下面的示例是<code class="highlighter-rouge">控制流语句</code>。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="o">(</span><span class="n">a</span> <span class="o">===</span> <span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
	<span class="c1">// do something</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="块">块</h2>
<p><strong>块</strong> 是语句的组合，在“块”的范围内可以有0或n个语句，<code class="highlighter-rouge">{}</code>花括号边上开始和结束，下面是块的示例。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kd">class</span> <span class="nc">BlockDemo</span> <span class="o">{</span>
     <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
          <span class="kt">boolean</span> <span class="n">condition</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
          <span class="k">if</span> <span class="o">(</span><span class="n">condition</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// 开始 块 1</span>
               <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Condition is true."</span><span class="o">);</span>
          <span class="o">}</span> <span class="c1">// 结束 块 one</span>
          <span class="k">else</span> <span class="o">{</span> <span class="c1">// 开始 块 2</span>
               <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Condition is false."</span><span class="o">);</span>
          <span class="o">}</span> <span class="c1">// 结束 块 2</span>
     <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="控制流语句">控制流语句</h2>
<p>控制流语分为3种，<strong>条件判断类型 ** (<code class="highlighter-rouge">if-then</code>,<code class="highlighter-rouge">if-then-else</code>,<code class="highlighter-rouge">switch</code>)、 **循环语句</strong> (<code class="highlighter-rouge">for</code>,<code class="highlighter-rouge">while</code>,<code class="highlighter-rouge">do-while</code>) 和 <strong>分支语句</strong> (<code class="highlighter-rouge">break</code>,<code class="highlighter-rouge">continue</code>,<code class="highlighter-rouge">return</code>)。</p>

<h3 id="条件判断语句">条件判断语句</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// if-then</span>
 <span class="k">if</span> <span class="o">(</span><span class="n">condition</span><span class="o">){</span> 
     <span class="c1">// then do something</span>
 <span class="o">}</span>
    
<span class="c1">// 省略括号的写法</span>
 <span class="k">if</span> <span class="o">(</span><span class="n">isMoving</span><span class="o">)</span>
      <span class="n">currentSpeed</span><span class="o">--;</span>

<span class="c1">// if-then-else </span>
<span class="k">if</span> <span class="o">(</span><span class="n">isMoving</span><span class="o">)</span> <span class="o">{</span>
       <span class="n">currentSpeed</span><span class="o">--;</span>
   <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">{</span>
       <span class="n">System</span><span class="o">.</span><span class="na">err</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"The bicycle has already stopped!"</span><span class="o">);</span>
   <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
    <span class="c1">// do something</span>
<span class="o">}</span>
	
<span class="c1">// switch 语句</span>
<span class="kt">int</span> <span class="n">month</span> <span class="o">=</span> <span class="mi">8</span><span class="o">;</span>
<span class="n">String</span> <span class="n">monthString</span><span class="o">;</span>
<span class="k">switch</span> <span class="o">(</span><span class="n">month</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">case</span> <span class="mi">1</span><span class="o">:</span>  <span class="n">monthString</span> <span class="o">=</span> <span class="s">"January"</span><span class="o">;</span>
             <span class="k">break</span><span class="o">;</span>
    <span class="k">case</span> <span class="mi">2</span><span class="o">:</span>  <span class="n">monthString</span> <span class="o">=</span> <span class="s">"February"</span><span class="o">;</span>
             <span class="k">break</span><span class="o">;</span>
    <span class="k">default</span><span class="o">:</span> <span class="n">monthString</span> <span class="o">=</span> <span class="s">"Invalid month"</span><span class="o">;</span>
             <span class="k">break</span><span class="o">;</span>
<span class="o">}</span>
    
</code></pre></div></div>

<h3 id="循环语句">循环语句</h3>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// while语句</span>
<span class="k">while</span> <span class="o">(</span><span class="n">count</span> <span class="o">&lt;</span> <span class="mi">11</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Count is: "</span> <span class="o">+</span> <span class="n">count</span><span class="o">);</span>
    <span class="n">count</span><span class="o">++;</span>
<span class="o">}</span>

<span class="c1">// do while语句</span>
<span class="k">do</span> <span class="o">{</span>
   <span class="n">statement</span><span class="o">(</span><span class="n">s</span><span class="o">)</span>
<span class="o">}</span> <span class="k">while</span> <span class="o">(</span><span class="n">expression</span><span class="o">);</span>

<span class="c1">// for循环</span>
<span class="kd">class</span> <span class="nc">ForDemo</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">){</span>
         <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">11</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
              <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Count is: "</span> <span class="o">+</span> <span class="n">i</span><span class="o">);</span>
         <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// for循环迭代的用法</span>
<span class="kd">class</span> <span class="nc">EnhancedForDemo</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">){</span>
         <span class="kt">int</span><span class="o">[]</span> <span class="n">numbers</span> <span class="o">=</span> 
             <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">6</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">8</span><span class="o">,</span><span class="mi">9</span><span class="o">,</span><span class="mi">10</span><span class="o">};</span>
         <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">item</span> <span class="o">:</span> <span class="n">numbers</span><span class="o">)</span> <span class="o">{</span>
             <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Count is: "</span> <span class="o">+</span> <span class="n">item</span><span class="o">);</span>
         <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>

<h3 id="分支语句">分支语句</h3>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="o">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">arrayOfInts</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">arrayOfInts</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="n">searchfor</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">foundIt</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="k">break</span><span class="o">;</span> <span class="c1">// 跳出循环</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="参考">参考</h2>
<p><a href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/expressions.html">The Java™ Tutorials</a></p>

	  ]]></description>
	</item>

	<item>
	  <title>Java学习笔记(二) - 原始数据类型</title>
	  <link>//Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)-%E5%8E%9F%E5%A7%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B</link>
	  <author></author>
	  <pubDate>2018-08-27T00:00:00+08:00</pubDate>
	  <guid>//Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)-%E5%8E%9F%E5%A7%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B</guid>
	  <description><![CDATA[
	     <h2 id="原始数据类型">原始数据类型</h2>
<p>Java是静态类型语言，所以变量必须先声明才能使用，并且每个变量都有自己的类型和名称。原始值不与其他原始数据值共享状态，Java语言定义了8种原始数据类型。</p>
<ul>
  <li><strong>byte</strong>   字节类型，在内存中占8位，它的值的范围是<code class="highlighter-rouge">-128 ~ 127</code>(包含)，在需要节省内存的情况下，字节类型可用来保存大型数组。</li>
  <li><strong>short</strong>  类型在内存中占16位，它的值的范围是<code class="highlighter-rouge">-32,768 ~ 32,767 </code>，和<code class="highlighter-rouge">byte</code>类型一样，同样适用于需要节省内存的情况。</li>
  <li><strong>int</strong> 类型在内存中占32位，它的值的范围是<strong>-2<sup>31</sup> ~ 2<sup>31</sup> -1</strong>。Java8之后可以使用无符号的整数，它的范围是**0 ~ 2<sup>32</sup> **，<code class="highlighter-rouge">Integer</code>中增加了静态方法<code class="highlighter-rouge">compareUnsigned</code>,<code class="highlighter-rouge">divideUnsigned</code>等方法可支持无符号整数运算。</li>
  <li><strong>long</strong>类型在内存中占64位，它的取值范围是<strong>-2<sup>63</sup> ~ 2<sup>63</sup> -1</strong>，Java8之后也可以使用无符号整数，通过<code class="highlighter-rouge">Long</code>类提供的<code class="highlighter-rouge">compareUnsigned</code>、<code class="highlighter-rouge">divideUnsigned</code>方法支持无符号整数运算。</li>
  <li><strong>float</strong>为32位单精度浮点类型。</li>
  <li><strong>dobule</strong>类型为64位双精度浮点类型。</li>
  <li><strong>boolean</strong>布尔类型，有<code class="highlighter-rouge">true/false</code>两种类型，通常用于条件判断<code class="highlighter-rouge">true</code>表<code class="highlighter-rouge">是</code>,<code class="highlighter-rouge">false</code>表<code class="highlighter-rouge">否</code>。</li>
  <li><strong>char</strong> 字符类型是单个16位<code class="highlighter-rouge">Unicode</code>字符，它的值范围是<code class="highlighter-rouge">'\u0000'</code>~<code class="highlighter-rouge">'\uffff'</code>。</li>
</ul>

<h2 id="默认值">默认值</h2>
<p>类的全局变量声明之后不是必须被分配的。如果全局变量被声明了，但是没有初始化，它会被编译器设置一个默认值，可能是<code class="highlighter-rouge">0</code>或<code class="highlighter-rouge">null</code>，这取决于数据类型，不过，依赖于默认值被认为是一种糟糕的编程风格。下表总结了各种数据类型对应的默认值</p>

<table>
  <thead>
    <tr>
      <th>数据类型</th>
      <th>默认值</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>byte</td>
      <td>0</td>
    </tr>
    <tr>
      <td>short</td>
      <td>0</td>
    </tr>
    <tr>
      <td>int</td>
      <td>0</td>
    </tr>
    <tr>
      <td>long</td>
      <td>0L</td>
    </tr>
    <tr>
      <td>float</td>
      <td>0.0f</td>
    </tr>
    <tr>
      <td>double</td>
      <td>0.0d</td>
    </tr>
    <tr>
      <td>char</td>
      <td>‘\u0000’</td>
    </tr>
    <tr>
      <td>String(或者 任何对象)</td>
      <td>null</td>
    </tr>
    <tr>
      <td>boolean</td>
      <td>false</td>
    </tr>
  </tbody>
</table>

<p>对于局部变量则不同，编译器永远不会给局部变量分配默认值，如果你在声明时未对该变量进行初始化，在你使用该变量之前必须对其初始化，否则将导致编译错误。</p>

<h2 id="字面量-literals">字面量-Literals</h2>
<p>在初始化原始数据类型时不需要<code class="highlighter-rouge">new</code>关键词，因为原始数据类型是语言中内置的数据类型，字面量就是原始数据类型变量的等号右边的，固定的值，可以是字符串或数字。如下所示，<code class="highlighter-rouge">100</code>和<code class="highlighter-rouge">true</code>就是字面量。</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">100</span><span class="o">;</span>
<span class="kt">boolean</span> <span class="n">result</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
</code></pre></div></div>
<p>字面量可以分为：</p>
<ul>
  <li><strong>整数字面量</strong></li>
  <li><strong>浮点数字面量</strong></li>
  <li><strong>字符串字面量</strong></li>
</ul>

<h2 id="参考">参考</h2>
<p><a href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html">The Java™ Tutorials</a></p>

	  ]]></description>
	</item>

	<item>
	  <title>Java学习笔记(一) - 变量</title>
	  <link>//Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)-%E5%8F%98%E9%87%8F</link>
	  <author></author>
	  <pubDate>2018-08-26T00:00:00+08:00</pubDate>
	  <guid>//Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)-%E5%8F%98%E9%87%8F</guid>
	  <description><![CDATA[
	     <h2 id="变量">变量</h2>
<p>Java语言定义了4中类型的变量</p>

<ul>
  <li><strong>实例变量</strong></li>
</ul>

<p>实例变量本质上是 <strong>一个类的非晶态的全局变量</strong>，注意关键词，<strong>非晶态</strong>和<strong>全局</strong>。为什么叫实例变量呢？因为它的值在类的每个实例都是唯一的，实例就是指对象。下面的例子中，有一个<code class="highlighter-rouge">Box</code>类，定义了一个全局变量<code class="highlighter-rouge">numbers=1</code>，在这里<code class="highlighter-rouge">box1</code>是类<code class="highlighter-rouge">Box</code>的第1个实例，<code class="highlighter-rouge">box2</code>是第2个实例，<code class="highlighter-rouge">numbers</code>变量在这2个实例中是独立的，修改了实例<code class="highlighter-rouge">box1</code>中的变量<code class="highlighter-rouge">numbers</code>不会对<code class="highlighter-rouge">box2</code>实例中的<code class="highlighter-rouge">numbers</code>造成影响。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Box</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kt">int</span> <span class="n">numbers</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
<span class="o">}</span>

<span class="n">Box</span> <span class="n">box1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Box</span><span class="o">();</span>
<span class="n">box1</span><span class="o">.</span><span class="na">numbers</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
<span class="n">Box</span> <span class="n">box2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Box</span><span class="o">();</span> <span class="c1">// box2的numbers属性依然是1</span>
</code></pre></div></div>

<ul>
  <li><strong>类变量</strong></li>
</ul>

<p>类变量指的是<strong>一个类的静态全局变量</strong>，关键词是，<strong>静态</strong>和<strong>全局</strong>。为什么叫类变量呢？因为它是和实例(对象)无关的，不管一个类被实例化多少次，类变量都只有一份。静态变量通过<code class="highlighter-rouge">static</code>关键词来声明，对第1个例子稍作修改，<code class="highlighter-rouge">numbers</code>变成了类变量，<code class="highlighter-rouge">box1</code>调用<code class="highlighter-rouge">getNumbers</code>方法得到的值为1，然后我们把<code class="highlighter-rouge">numbers</code>的值改为了2，<code class="highlighter-rouge">box2</code>调用<code class="highlighter-rouge">getNumbers</code>的值变成了2，结果说明了<code class="highlighter-rouge">类变量</code>只和类有关 。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Box</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="n">numbers</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
	
	<span class="kd">public</span> <span class="kt">int</span> <span class="nf">getNumbers</span><span class="o">()</span> <span class="o">{</span>
		<span class="k">return</span> <span class="n">Box</span><span class="o">.</span><span class="na">numbers</span><span class="o">;</span>
	<span class="o">}</span>
<span class="o">}</span>

<span class="n">Box</span> <span class="n">box1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Box</span><span class="o">();</span>
<span class="n">box1</span><span class="o">.</span><span class="na">getNumbers</span><span class="o">();</span><span class="c1">// 得到的值为1</span>
<span class="n">Box</span><span class="o">.</span><span class="na">numbers</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span> <span class="c1">// 修改全局变量</span>
<span class="n">Box</span> <span class="n">box2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Box</span><span class="o">();</span> 
<span class="n">box2</span><span class="o">.</span><span class="na">getNumbers</span><span class="o">();</span> <span class="c1">// 得到的值为2</span>
</code></pre></div></div>

<ul>
  <li><strong>局部变量</strong></li>
</ul>

<p>Java中的局部变量是指<strong>类的方法内部的变量</strong>，局部变量仅在方法内部可见，在类的外部无法被访问到，通常用于存储一个方法的临时状态，在方法执行完成后，会自动释放掉。如下所示<code class="highlighter-rouge">getNumbers</code>方法中的<code class="highlighter-rouge">numbers</code>就是局部变量。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Box</span> <span class="o">{</span>
	
	<span class="kd">public</span> <span class="kt">int</span> <span class="nf">getNumbers</span><span class="o">()</span> <span class="o">{</span>
		<span class="kt">int</span> <span class="n">numbers</span> <span class="o">=</span> <span class="mi">1</span>
		<span class="k">return</span> <span class="n">numbers</span><span class="o">;</span>
	<span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>

<ul>
  <li><strong>参数</strong></li>
</ul>

<p>参数变量是指方法中的参数，它的作用域和局部变量一样，仅在方法内有效，可以接受来自外部的数据。如下所示，<code class="highlighter-rouge">numbers</code>作为<code class="highlighter-rouge">getNumbers</code>方法的参数。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Box</span> <span class="o">{</span>
	
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">getNumbers</span><span class="o">(</span><span class="kt">int</span> <span class="n">numbers</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">numbers</span><span class="o">);</span>
	<span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>

<h2 id="命名规范">命名规范</h2>
<ul>
  <li>变量命名大小写敏感，不限制长度，可以由一系列Unicode的字符和数字组成，用<code class="highlighter-rouge">字母</code>，<code class="highlighter-rouge">$</code>和<code class="highlighter-rouge">_</code>都是被允许的，包括中文，技术上是不限制的，但是Java规范不建议用<code class="highlighter-rouge">$</code>和<code class="highlighter-rouge">_</code>作为开头。</li>
  <li>命名的尽量只用全称而非简称，写全称的代码可读性和可维护性都更好，好的命名，在很多情况下就是文档本身，另外需要注意，变量的名称不能为Java的关键词和保留字。</li>
  <li>变量名称涉及多个单词的，第二个单词开始开头字母大写，也就是驼峰命名法，例如<code class="highlighter-rouge">boxNumbers</code>。如果是常量或者不能改变的变量，所有字母都用大写，字母之间用<code class="highlighter-rouge">_</code>隔开，例如<code class="highlighter-rouge">BOX_CONFIG</code>。</li>
</ul>

<h2 id="参考">参考</h2>
<p><a href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/variables.html">The Java™ Tutorials</a></p>

	  ]]></description>
	</item>

	<item>
	  <title>IO模型浅析</title>
	  <link>//IO%E6%A8%A1%E5%9E%8B%E6%B5%85%E6%9E%90</link>
	  <author></author>
	  <pubDate>2018-07-27T01:00:00+08:00</pubDate>
	  <guid>//IO%E6%A8%A1%E5%9E%8B%E6%B5%85%E6%9E%90</guid>
	  <description><![CDATA[
	     <h2 id="同步阻塞io">同步阻塞IO</h2>
<p>系统的输入分为两个步骤：</p>
<ol>
  <li>等待数据报的到来</li>
  <li>将数据报从内核缓冲区复制到用户应用程序缓冲区</li>
</ol>

<p>同步阻塞IO在以上两个步骤上都是阻塞状态，这时候CPU处于空闲状态，不会分配时间片给用户线程。在实际场景下，同一时刻往往会有多个IO操作，同步阻塞IO不能同时处理多个IO，只能一个一个来，导致CPU资源被浪费。</p>

<h2 id="同步非阻塞io">同步非阻塞IO</h2>
<p>同步非阻塞IO比同步阻塞稍微好点，两者的区别是，在第一步调用<code class="highlighter-rouge">recvfrom</code>系统调用的时候，如果数据报还没有准备好会立即返回错误码<code class="highlighter-rouge">EAGAIN</code>或<code class="highlighter-rouge">EWOULDBLOCK</code>，并且一直轮询调用，直到数据报准备好时，执行第2步，第2步仍然是阻塞执行的，它的问题是会产生大量的系统调用，是很大的开销。</p>

<h2 id="io多路复用">IO多路复用</h2>
<p>多路复用和同步阻塞区别也是在第1步，当用户进程调用了<code class="highlighter-rouge">select</code>,<code class="highlighter-rouge">poll</code>或者<code class="highlighter-rouge">epoll</code>函数时，进程会监听文件描述符，当有数据报到来时，就执行第2步。多路复用在服务端编程中很常用，nginx、redis和nodeJs底层都使用了基于<code class="highlighter-rouge">epoll</code>的IO模型。它的优势是。<strong>1.</strong> 相对多线程而言，多个线程修改数据会产生静态条件，需要加锁处理。<strong>2.</strong>单线程模型避免了线程间切换的开销，可同时接受多个客户端的IO操作。<strong>3.</strong>事件驱动，当数据报准备好时才拷贝数据到用户控件，高效利用CPU资源。</p>

<h2 id="异步io">异步IO</h2>
<p>上面三种IO模型本质上都是同步的，因为在第2步的时候，数据报从内核缓冲区拷贝到用户进程的操作是阻塞的。异步IO和同步IO区别在于2步，当用户进程调用<code class="highlighter-rouge">aio_read</code>操作时就立刻返回，进程可以去做别的事情，1，2步操作都由内核帮你完成。当整个IO操作完成时，内核通过信号或回调函数的方式通知用户进程，这样1，2步都是非阻塞的。</p>


	  ]]></description>
	</item>

	<item>
	  <title>浅入浅出MySQL事务</title>
	  <link>//%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAMySQL%E4%BA%8B%E5%8A%A1</link>
	  <author></author>
	  <pubDate>2018-03-27T00:00:00+08:00</pubDate>
	  <guid>//%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAMySQL%E4%BA%8B%E5%8A%A1</guid>
	  <description><![CDATA[
	     <p>在开发Web应用时，经常会用到InnoDB事务的特性，在一些涉及到金钱的业务上，事务可以保证资金流水不出错，事务可以分为很多种，有扁平事务、链事务、分布式事务等，这里只讨论最简单，也最常用的扁平事务，我们经常会提到事务的<code class="highlighter-rouge">ACID</code>特性，以下是我对<code class="highlighter-rouge">ACID</code>的理解和总结。</p>

<ul>
  <li>原子性</li>
  <li>一致性</li>
  <li>隔离性</li>
  <li>持久性</li>
</ul>

<h4 id="原子性">原子性</h4>
<p>原子性指的是对于一系列增删改查的操作，要么全部执行，要么全部不执行，事务可通过<code class="highlighter-rouge">start transaction</code>或者<code class="highlighter-rouge">begin</code>语句显示的开启，<code class="highlighter-rouge">commit</code>用于显示的提交，例如：</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">start</span> <span class="n">transaction</span>
<span class="k">update</span> <span class="nv">`user`</span> <span class="k">set</span> <span class="n">name</span><span class="o">=</span><span class="s1">'haha'</span> <span class="k">where</span> <span class="n">uid</span><span class="o">=</span><span class="mi">1</span>
<span class="k">insert</span> <span class="k">into</span> <span class="nv">`user`</span> <span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="k">values</span> <span class="p">(</span><span class="s1">'小马'</span><span class="p">)</span>
<span class="k">commit</span>
</code></pre></div></div>
<p>对于以上两部操作，若成功则都成功，若由于某些原因第二条语句执行出错，则可以执行<code class="highlighter-rouge">rollback</code>语句，这些一般是由程序语言来控制。
<!-- more --></p>
<h4 id="一致性">一致性</h4>
<p>一致性和原子性有很多相似的地方，我的理解是，一致性的特点是依赖于原子性实现的，什么意思呢？比如说A给B汇款1000元，这个状态分为两步即：</p>

<ol>
  <li>从A的账户扣1000元</li>
  <li>再往B的账户+1000元</li>
</ol>

<p>这两个步骤，对于事务的原子性来说，指要么都成功，要么都失败，原子性关注的是状态，而一致性关注的是最终的金额是否一致，即1000元不会丢失，可能理解起来会有点歧义，它们之间有相似的地方，一致性依赖于原子性实现。参考 <a href="http://geyifan.cn/2016/07/17/talk-about-transaction/">事务隔离级别浅析</a>。</p>

<h4 id="隔离性">隔离性</h4>
<p>隔离性指的是事务在提交之前，对其它事务是不可见的，每个事务对对象的操作相对其它事务都是相互分离的，这个特性依靠锁机制来实现。</p>

<h4 id="持久性">持久性</h4>
<p>持久性指的是事务一旦提交，其结果是永久性的，即使发生宕机等故障，数据库也能将数据恢复。</p>

<h3 id="事务的隔离级别">事务的隔离级别</h3>
<p>在数据库操作中，为了解决并发数据读写时数据的正确性问题，提出了事务的隔离级别。数据库的锁也是为了构建这些隔离级别而存在的。下面是SQL标准定义的四个隔离级别，以及可能发生脏读、不可重复读、幻读的可能性，隔离级别从上往下一次递增。</p>

<table>
  <thead>
    <tr>
      <th>隔离级别</th>
      <th>脏读</th>
      <th>不可重复读</th>
      <th>幻读</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>未提交读（Read uncommitted）</td>
      <td>可能</td>
      <td>可能</td>
      <td>可能</td>
    </tr>
    <tr>
      <td>已提交读（Read committed）</td>
      <td>不可能</td>
      <td>可能</td>
      <td>可能</td>
    </tr>
    <tr>
      <td>可重复读（Repeatable read）</td>
      <td>不可能</td>
      <td>不可能</td>
      <td>可能</td>
    </tr>
    <tr>
      <td>可串行化（Serializable ）</td>
      <td>不可能</td>
      <td>不可能</td>
      <td>不可能</td>
    </tr>
  </tbody>
</table>

<h4 id="脏读不可重复读幻读">脏读、不可重复读、幻读</h4>
<p>要理解事务的隔离级别，首先要理解脏读、不可重复读和幻读是什么意思，下面通过几个例子来演示一下。</p>
<ul>
  <li><strong>脏读</strong></li>
</ul>

<table>
  <thead>
    <tr>
      <th>事务A</th>
      <th>事务B</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="highlighter-rouge">START TRANSACTION</code></td>
      <td><code class="highlighter-rouge">START TRANSACTION</code></td>
    </tr>
    <tr>
      <td> </td>
      <td><code class="highlighter-rouge">update user set name='小马' where uid=1</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">select * from user where uid=1</code></td>
      <td> </td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">commit</code></td>
      <td><code class="highlighter-rouge">rollback</code></td>
    </tr>
  </tbody>
</table>

<p>在<code class="highlighter-rouge">Read uncommitted</code>隔离级别下，A事务和B事务同时开启，B事务对uid=1的这行数据做了修改操作，没有提交，但是在事务A里面已经能被读取到，而此时事务B执行了<code class="highlighter-rouge">rollback</code>回滚操作，也就是说A读到的是一行不存在的数据，这种情况被称为<code class="highlighter-rouge">脏读</code>，只有在<code class="highlighter-rouge">未提交读</code>的隔离级别下才会发生这种情况。</p>

<ul>
  <li><strong>可重复读</strong></li>
</ul>

<table>
  <thead>
    <tr>
      <th>事务A</th>
      <th>事务B</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="highlighter-rouge">START TRANSACTION</code></td>
      <td><code class="highlighter-rouge">START TRANSACTION</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">select * from user where uid = 1</code></td>
      <td>…</td>
    </tr>
    <tr>
      <td>…</td>
      <td><code class="highlighter-rouge">update user set name='小马' where uid=1</code></td>
    </tr>
    <tr>
      <td>…</td>
      <td><code class="highlighter-rouge">commit</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">select * from user where uid = 1</code></td>
      <td>…</td>
    </tr>
  </tbody>
</table>

<p>不可重复读指的是在一个事务中，执行两次查询操作，两次结果是不一样的，称为不可重复读，可重复读则相反，同一个事务内，两次读到的数据一致。根据上面的例子，事务A和事务B同时开启，第一次A事务通过<code class="highlighter-rouge">select</code>语句查询uid=1的这行数据，这时候B修改了这行数据并且执行了提交操作，第二次A事务再通过<code class="highlighter-rouge">select</code>语句查询这行数据的时候，读取到的结果就不一样了，所以称为不可重复读，这种情况在<code class="highlighter-rouge">Read committed</code>隔离级别下存在，<code class="highlighter-rouge">Repeatable read</code>级别则实现了可重复读。</p>

<ul>
  <li><strong>幻读</strong></li>
</ul>

<table>
  <thead>
    <tr>
      <th>事务A</th>
      <th>事务B</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="highlighter-rouge">START TRANSACTION</code></td>
      <td><code class="highlighter-rouge">START TRANSACTION</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">select count(*) from user</code></td>
      <td>…</td>
    </tr>
    <tr>
      <td>…</td>
      <td><code class="highlighter-rouge">insert into user (name) values ('mike')</code></td>
    </tr>
    <tr>
      <td>…</td>
      <td><code class="highlighter-rouge">commit</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">select count(*) from user</code></td>
      <td>…</td>
    </tr>
  </tbody>
</table>

<p>幻读和不可重复读有一些相似的地方，不可重复读针对的是修改删除操作，这两种操作可通过对数据行增加一个排它锁来解决，但是<code class="highlighter-rouge">insert</code>操作不一样，你没有办法锁住一条尚未存在的数据，理论上在<code class="highlighter-rouge">Repeatable read</code>隔离级别只解决了不可重复读问题，没有解决幻读问题，RR级别也是innodb默认的隔离级别，值得庆幸的是，innodb的RR级别通过MVCC多版本并发控制，解决了在RR级别下的幻读问题，所以理论上Innodb是完全满足事务的ACID属性的，想详细了解MVCC的同学可自行搜索引擎或者看书，本文由于篇幅的原因，暂不详细展开。</p>

<h3 id="总结">总结</h3>
<p>理解了上面说的这些概念，就很容易理解事务的隔离级别了，下面是对事务隔离级别的总结：</p>
<ul>
  <li><strong>未提交读：</strong>允许脏读，A事务可以读到B事务未提交的数据</li>
  <li><strong>已提交读：</strong>A事务只能读到B事务已提交的数据</li>
  <li><strong>可重复读：</strong>A事务对于同一行数据，前后两次读到的数据一定是一样的，即使B事务对它执行了修改，且提交了，结果也不会变。</li>
  <li><strong>串行化：</strong>完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞</li>
</ul>

<h3 id="参考">参考</h3>
<ul>
  <li><a href="https://book.douban.com/subject/5373022/"><em>《MySQL技术内幕：InnoDB存储引擎》</em></a></li>
  <li><a href="https://tech.meituan.com/innodb-lock.html"><em>Innodb中的事务隔离级别和锁的关系</em></a></li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>Git原理和用法</title>
	  <link>//Git%E5%8E%9F%E7%90%86%E5%92%8C%E7%94%A8%E6%B3%95</link>
	  <author></author>
	  <pubDate>2018-03-23T00:00:00+08:00</pubDate>
	  <guid>//Git%E5%8E%9F%E7%90%86%E5%92%8C%E7%94%A8%E6%B3%95</guid>
	  <description><![CDATA[
	     <p>git是一个分布式版本管理工具，所谓分布式，也就是指每台电脑都是一个版本仓库，虽然git是分布式的，但在实际工作中，一般git还是会有一个集中的服务中心，目前比较主流的<code class="highlighter-rouge">GITHUB</code>和码云就是这样一个角色，当然你也可以搭建git服务器，然后全世界的开发者就可以通过互联网一起协同工作啦。很多小伙伴在工作上都会用到版本管理工具，我相信现在大部分互联网公司都会使用git来做版本管理工具，写这篇文章的目的是因为虽然自己每天都在用，但是仔细想想，对它的原理和执行过程没有一个深入的理解，往往只是停留在会用的阶段，不光是这个，其实很多时候，我们平时在用的一些开源框架或者库的时候，大多数人可能仅仅会用，不会去理解本质和原理是什么？然后那些原理和基础才是最重要的，正所谓要知其然，也要知其所以然，可能这就是高手和普通人的差距吧。Linus有句话叫<code class="highlighter-rouge">Read The Fucking Source Code</code>，这个话虽然简单粗暴，仔细想想却很有道理。</p>

<h3 id="工作原理">工作原理</h3>
<p><code class="highlighter-rouge">Git</code>整体可以分为三部分：工作区、暂存区和分支，在我们的git工作目录下，有一个<code class="highlighter-rouge">.git</code>文件，这个文件就是我们常说的版本库，要注意的是<code class="highlighter-rouge">Git</code>是通过快照的方式保存版本的，和传统版本管理工具不同，git不保存不同版本之间的差异，只以快照的方式保存修改后的文件，如果文件没有被修改，git就不会保存，这也是git比传统工具更高效的原因，但也有一个缺点，由于每次保存的都是快照，相当于把修改后的文件复制一份保存起来，这难免会造成空间浪费，因此版本提交多了之后，<code class="highlighter-rouge">.git</code>文件会变得很大。</p>

<p><img src="https://img.ydlcdn.com/file/2018/03/27/a4h7idphq8q4kjhy.jpg" alt="enter image description here" /></p>

<p><strong>工作区</strong>
工作区就是我们工作的文件夹目录
<strong>暂存区</strong>
Git和其它版本管理工具一个不同之处就在于，git有一个暂存区，当我们执行<code class="highlighter-rouge">git add</code>命令的时候，我们实际上就是把修改后的文件放入到这个暂存区，而不是直接发布版本
<strong>分支</strong>
分支区域存放的是我们发布的各个版本，每次执行<code class="highlighter-rouge">git commit</code>操作时，git会生成一个hash值作为版本号，然后把暂存区的文件放入分支区域，也就是发布了一个版本，因为一个代码仓库一般会有好几个分支，所以这个提交的分支仅仅指向你当前正在使用的那个。换句话说，暂存区就是为版本发布做准备的，提交之后暂存区的就被清空了。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git add // 添加修改后的文件到暂存区
<span class="nv">$ </span>git commit // 提交文件到分支
<span class="nv">$ </span>git status // 查看当前文件状态
</code></pre></div></div>

<p>我们可以通过<code class="highlighter-rouge">git status</code>命令来查看文件修改的状态，这个状态只的是目前工作区的文件以及暂存区的文件，和当前本地的分支库文件之间的差异，如果修改了<code class="highlighter-rouge">readme.md</code>文件，git就会在执行这条命令后展示出所有被修改过但是没有正式提交的文件。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git branch dev // 新建dev分支
<span class="nv">$ </span>git branch <span class="nt">-d</span> dev // 删除dev分支
<span class="nv">$ </span>git checkout <span class="nt">-b</span> dev // 切换并新创建一个dev分支
<span class="nv">$ </span>git merge dev // 合并当前分支到dev分支
</code></pre></div></div>

<h3 id="版本回退">版本回退</h3>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git log // 从近到远查看提交日志
<span class="nv">$ </span>git reset <span class="nt">--hard</span> HEAD^ // 回退到上一个版本，^^两个箭头就表示上上个版本，依次类推
<span class="nv">$ </span>git reset <span class="nt">--hard</span> 3628164 // 回退到指定版本号
<span class="nv">$ </span>git reflog // 查看最近几次提交记录的版本号
</code></pre></div></div>
<p>在某些情况下，比如说因为某些原因，我从2.0版本回退到了1.0版本，这个操作可以通过<code class="highlighter-rouge">git reset --hard HEAD^</code>命令实现，但是这时我又想回到2.0版本怎么办呢？这时候去查看<code class="highlighter-rouge">git log</code>命令，发现最新的版本是<code class="highlighter-rouge">1.0</code>，<code class="highlighter-rouge">git log</code>查看的是提交历史，似乎是没有什么办法回到2.0版本了。答案是 <code class="highlighter-rouge">git reflog</code>命令，该命令可以查看命令历史，可以通过找到2.0的版本号，再通过<code class="highlighter-rouge">git reset --hard </code>回到2.0版本。</p>

<h3 id="撤销修改">撤销修改</h3>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git checkout <span class="nt">--</span> readme.txt // 把readme.txt在工作区的修改全部撤销
<span class="nv">$ </span>git reset HEAD readme.txt // 把readme.txt暂存区的修改撤销，重新放回工作区 
</code></pre></div></div>
<p>修改文件的时候，突然发现文件修改错了，但是这时候已经修改了很多，无法手动恢复，趁还没有<code class="highlighter-rouge">git add</code>的时候把它恢复，可以执行<code class="highlighter-rouge">git checkout -- filename</code>命令。如果当你发现的时候已经执行了<code class="highlighter-rouge">git add</code>操作，也就是文件的修改已经被提交到了暂存区怎么办呢？这时候就应该先执行<code class="highlighter-rouge">git reset HEAD filename</code>命令，把缓存区的修改放回工作区，再执行<code class="highlighter-rouge">git checkout -- filename</code>撤销工作区修改的文件。当你删除文件时候，也可以通过<code class="highlighter-rouge">git checkout -- filename</code>命令恢复，因为对git来说，删除也是一种修改。</p>

<h3 id="分支管理">分支管理</h3>
<p>在实际开发中，可能会有很多分支，我们一般会把它们分为固定分支和临时分支，固定分支通常为<code class="highlighter-rouge">master</code>分支，指的是生产环境下的版本，<code class="highlighter-rouge">dev</code>为开发环境分支，用于开发完测试Bug，然后合并上线，这两个一般是固定的。临时分支一般是指，针对某个功能的开发而创建的分支，使用完就删除了。
<strong>可参考：</strong>http://www.ruanyifeng.com/blog/2012/07/git.html</p>


	  ]]></description>
	</item>

	<item>
	  <title>Hexo + Github Pages 搭建个人博客</title>
	  <link>//Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2</link>
	  <author></author>
	  <pubDate>2018-03-18T00:00:00+08:00</pubDate>
	  <guid>//Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2</guid>
	  <description><![CDATA[
	     <h2 id="一什么是hexo">一、什么是Hexo?</h2>
<p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 <a href="https://zh.wikipedia.org/wiki/Markdown">Markdown</a>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p>

<h2 id="二准备工作">二、准备工作</h2>
<p>你需要：
1、<code class="highlighter-rouge">NodeJS</code>环境，请参考 <a href="https://nodejs.org/en/download/">NodeJs官网</a>
2、<code class="highlighter-rouge">Git</code>，请参考 <a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000">廖雪峰的Git教程</a>
3、一个<a href="https://github.com">Github</a>账号</p>

<h2 id="三安装hexo">三、安装Hexo</h2>
<p>检验NodeJs安装：</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>node <span class="nt">-v</span>
</code></pre></div></div>
<p>若安装成功会显示<code class="highlighter-rouge">NodeJs</code>版本号，例如：</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>v9.6.1
</code></pre></div></div>
<p>接着，在命令行中输入：</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>npm install <span class="nt">-g</span> hexo-cli
</code></pre></div></div>
<p>由于国外网络延迟的关系，下载速度太慢或者某些依赖安装失败，请安装<code class="highlighter-rouge">淘宝NPM镜像</code>，设置镜像的方法和使用规则详见：<a href="https://npm.taobao.org/">https://npm.taobao.org</a>。
至此，若无意外情况，Hexo安装完毕，若有疑问请参考 <a href="https://hexo.io/zh-cn/docs/index.html">Hexo官方手册</a></p>

<h2 id="四github-pages使用">四、Github Pages使用</h2>
<p>1、登录<code class="highlighter-rouge">Github</code>，在右上角选择<code class="highlighter-rouge">New repository</code>，新建一个<code class="highlighter-rouge">repository</code>，并且命名为<code class="highlighter-rouge">username.github.io</code>，注意把<code class="highlighter-rouge">username</code>替换成你申请账号的用户名，其余不要变。
2、使用 <code class="highlighter-rouge">git clone https://github.com/MeetMax/meetmax.github.io.git</code> 命令将项目克隆到本地，这里以我自己的项目为例。
3、进入文件夹 <code class="highlighter-rouge">cd meetmax.github.io</code> 
4、新建 <code class="highlighter-rouge">index.html</code> 文件，在里面输入</p>
<pre><code class="language-htmlbars">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
	&lt;title&gt;hello world&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
hello world
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>5、将文件提交到 <code class="highlighter-rouge">Github</code> 仓库，在<code class="highlighter-rouge">meetmax.github.io</code>文件夹运行命令：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git add <span class="nb">.</span>
<span class="nv">$ </span>git commit <span class="nt">-m</span> <span class="s2">"hello"</span>
<span class="nv">$ </span>git push origin master
</code></pre></div></div>

<p>6、在浏览器打开 <code class="highlighter-rouge">https://meetmax.github.io/</code>，若显示<code class="highlighter-rouge">hello world</code>则说明配置成功，注意将<code class="highlighter-rouge">meetmax</code>替换成自己的账号。</p>

<h2 id="五搭建hexo博客">五、搭建Hexo博客</h2>
<h4 id="1-初始化博客目录">1. 初始化博客目录</h4>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>hexo init meetmax.github.io
<span class="nv">$ </span><span class="nb">cd </span>meetmax.github.io
<span class="nv">$ </span>npm install
</code></pre></div></div>
<h4 id="2-生成静态页面">2. 生成静态页面</h4>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>hexo clean // 清空代码，初始化
<span class="nv">$ </span>hexo g // g表示generate，生成静态页面
</code></pre></div></div>
<h4 id="3--运行项目">3.  运行项目</h4>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>hexo s // s 表示 server
</code></pre></div></div>
<p>然后打开浏览器输入：<code class="highlighter-rouge">http://localhost:4000/</code>查看</p>
<h4 id="4-发布文章">4. 发布文章</h4>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>hexo new <span class="nb">test</span>
</code></pre></div></div>
<p>这时候会在<code class="highlighter-rouge">source/_post</code>文件夹生成<code class="highlighter-rouge">test.md</code>文件，或者直接手动在<code class="highlighter-rouge">source/_post</code>文件夹下新建<code class="highlighter-rouge">test.md</code>文件。再次运行命令：</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>hexo clean
<span class="nv">$ </span>hexo g 
<span class="nv">$ </span>hexo s
</code></pre></div></div>
<h4 id="5--配置">5.  配置</h4>

<p>网站的配置大部分都在<code class="highlighter-rouge">_config.yml</code>文件中：</p>
<ul>
  <li>title -&gt; 网站标题</li>
  <li>subtitle -&gt; 网站副标题</li>
  <li>description -&gt; 网站描述</li>
  <li>author -&gt; 作者名字</li>
  <li>language -&gt; 网站使用语言</li>
</ul>

<h4 id="6-需要注意的坑">6. 需要注意的坑</h4>
<p><em>配置文件名字冒号后面必须加空格，例如 <code class="highlighter-rouge">title: meetmax</code></em>，否则配置不生效。</p>

<h4 id="7-更换主题">7. 更换主题</h4>
<p>我用的是<code class="highlighter-rouge">Yilia</code>主题，这里就以该主题为例
1、克隆主题到 <code class="highlighter-rouge">theme</code> 文件夹</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">cd </span>themes
<span class="nv">$ </span>git clone https://github.com/litten/hexo-theme-yilia.git
</code></pre></div></div>
<p>2、配置主题
修改项目文件夹下的<code class="highlighter-rouge">_config.yml</code>文件，配置如下：  <code class="highlighter-rouge">注意加空格，否则无效</code></p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>theme: hexo-theme-yilia
</code></pre></div></div>
<h2 id="六部署到github">六、部署到Github</h2>
<h4 id="1-安装-hexo-deployer-git">1. 安装 hexo-deployer-git</h4>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>npm install hexo-deployer-git <span class="nt">--save</span>
</code></pre></div></div>
<p>若出现下面的错误，请设置<code class="highlighter-rouge">public key</code>，若不懂请使用搜索引擎</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Permission denied <span class="o">(</span>publickey<span class="o">)</span><span class="nb">.</span>
fatal: Could not <span class="nb">read </span>from remote repository.
Please make sure you have the correct access rights
and the repository exists.
</code></pre></div></div>
<h4 id="2-在_configyml中配置-git以我自己的为例">2. 在<code class="highlighter-rouge">_config.yml</code>中配置 Git，以我自己的为例：</h4>
<p>这里要注意 <code class="highlighter-rouge">repo</code>是 <code class="highlighter-rouge">ssh</code>地址，非 <code class="highlighter-rouge">https</code></p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>deploy:
  type: git
  repo: git@github.com:MeetMax/meetmax.github.io.git
  branch: master
</code></pre></div></div>
<h4 id="3-部署到github">3. 部署到Github</h4>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>hexo d // d表示deloy
</code></pre></div></div>
<h4 id="4访问">4.访问</h4>
<p>打开浏览器访问：https://meetmax.github.io/</p>

<h2 id="参考">参考</h2>
<p><a href="https://linghucong.js.org/2016/04/15/2016-04-15-hexo-github-pages-blog/">手把手教你使用Hexo + Github Pages搭建个人独立博客</a>
<a href="https://github.com/limedroid/HexoLearning">Hexo 博客搭建指南</a></p>


	  ]]></description>
	</item>

	<item>
	  <title>Redis应用场景浅析</title>
	  <link>//Redis%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E6%B5%85%E6%9E%90</link>
	  <author></author>
	  <pubDate>2018-03-16T00:00:00+08:00</pubDate>
	  <guid>//Redis%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E6%B5%85%E6%9E%90</guid>
	  <description><![CDATA[
	     <h3 id="string字符串">String–字符串</h3>
<p>redis最能想到的就是使用序列化的字符串缓存，通常为json格式，把一些在mysql中需要大量sql查询操作和计算得到的数据缓存起来，再次访问的时候就可以直接读取数据，可有效降低数据库的压力，例如网站首页的某些排名信息，查询比较复杂，但是对实时性要求没那么高的，可以设置一个定时过期的缓存，这是最简单的缓存应用场景，redis提供了丰富的数据结构，可以用在很多web应用的场景。</p>

<h3 id="hash哈希">Hash–哈希</h3>
<p>哈希表是redis中很有用的数据结构，有时候我们需要存储结构话的数据，例如用户的登录信息</p>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">uid</span><span class="p">:</span><span class="mi">1</span><span class="w"> </span><span class="err">//</span><span class="w"> </span><span class="err">用户uid</span><span class="w">
</span><span class="err">username</span><span class="p">:</span><span class="err">xxx</span><span class="w"> </span><span class="err">//</span><span class="w"> </span><span class="err">用户名</span><span class="w">
</span><span class="err">age</span><span class="p">:</span><span class="mi">18</span><span class="w"> </span><span class="err">//</span><span class="w"> </span><span class="err">年龄</span><span class="w">
</span><span class="err">head</span><span class="p">:</span><span class="err">xxx</span><span class="w"> </span><span class="err">//头像</span><span class="w">
</span></code></pre></div></div>

<h4 id="string模式">String模式</h4>
<p>按照普通缓存的模式，存储这个结构需要先将其序列化，转换成json字符串，以<code class="highlighter-rouge">user-uid</code>为键名，这样做有个问题，假如说现在需要修改<code class="highlighter-rouge">head</code>字段，我需要经历如下步骤：</p>
<ol>
  <li>根据键名<code class="highlighter-rouge">user-1</code>获取到<code class="highlighter-rouge">json</code>字符串</li>
  <li>解析<code class="highlighter-rouge">json</code></li>
  <li>修改结构体中的<code class="highlighter-rouge">head</code>字段</li>
  <li>再次序列化成<code class="highlighter-rouge">json</code></li>
  <li><code class="highlighter-rouge">set key</code> 存储</li>
</ol>

<h4 id="hash模式">Hash模式</h4>
<p>接下来使用<code class="highlighter-rouge">Hash</code>来存储，使用<code class="highlighter-rouge">HMSET</code>命令存储所有字段</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>HMSET user-1 uid 1 username xxx age 18 head:xxx
</code></pre></div></div>
<p>这时候需要修改字段<code class="highlighter-rouge">head</code>仅需一条命令即可：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>HSET user-1 head zzz
</code></pre></div></div>
<p>相比之下是不是简单了很多，<code class="highlighter-rouge">Hash模式</code>不仅操作大大简化，而且节省了<code class="highlighter-rouge">String模式</code>中大量的序列化和反序列化的性能消耗。</p>

<h3 id="list--列表">List – 列表</h3>
<p><code class="highlighter-rouge">List</code>在<code class="highlighter-rouge">redis</code>中的应用也比较广泛，最典型的就是消息队列，在某些高并发场景下，由于<code class="highlighter-rouge">mysql</code>存储介质为磁盘，在写入性能上由于磁盘的读写速度限制，它的写入速度可能达不到要求。但是<code class="highlighter-rouge">redis</code>不一样，redis是完全基于内存数据库<code class="highlighter-rouge">nosql</code>，没有<code class="highlighter-rouge">I/O</code>瓶颈，写入和读取速度都非常快，这也是<code class="highlighter-rouge">redis</code>流行的原因。假设现在要做一个商城的秒杀活动，在同一时刻必然会有大量的订单提交操作，mysql可能来不及写入，会导致其它用户阻塞，糟糕的情况下甚至系统奔溃，影响用户体验。在这种场景下就可以通过消息队列来处理，即：</p>
<ol>
  <li>先把提交的订单信息写入消息队列，可通过<code class="highlighter-rouge">LPUSH</code>和<code class="highlighter-rouge">RPOP</code>命令实现<code class="highlighter-rouge">入队</code>和<code class="highlighter-rouge">出队</code>的操作。</li>
  <li>通过异步程序将订单存储到<code class="highlighter-rouge">mysql</code></li>
</ol>

<p>另一种场景是可作为<code class="highlighter-rouge">IM</code>聊天系统的<code class="highlighter-rouge">timeline</code>模型，即每个用户对应一个<code class="highlighter-rouge">timeline</code>模型，根据时间顺序排列，每个用户通过<code class="highlighter-rouge">timeline</code>获取消息</p>

<h3 id="set--集合">Set – 集合</h3>
<p>集合和<code class="highlighter-rouge">List</code>的类似，区别是集合是可以自动排重的，且集合是无序的。例如：存储某个用户的所有粉丝和所有的好友等。</p>

<h3 id="sorted-set-有序集合">Sorted Set 有序集合</h3>
<p>有序集合根据<code class="highlighter-rouge">score</code>字段来排序，通过<code class="highlighter-rouge">ZADD</code>可添加一个有序集合，例如：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ZADD page_rank 10 google.com
</code></pre></div></div>
<p>上面命令的意思是在<code class="highlighter-rouge">page_rank</code>集合中添加字符串<code class="highlighter-rouge">google.com</code>，<code class="highlighter-rouge">score</code>为<code class="highlighter-rouge">10</code>。
有序集合可用来数据分页，例如我们查询用户积分前100名的用户，每页20条展示，通过
<code class="highlighter-rouge">ZRANGE key start stop [WITHSCORES]</code>命令可实现分页，时间复杂度为<code class="highlighter-rouge">O(log(N)+M)</code>，
在数据量大，查询比较耗时，可大大提高web的性能。</p>

<h3 id="pubsub--发布--订阅">Pub/Sub – 发布 / 订阅</h3>
<p>发布订阅模式通过发布和订阅发送和接收消息，例如A和B订阅(<code class="highlighter-rouge">subscribe</code>)了频道<code class="highlighter-rouge">news.it</code>，这时候C向改频道发送(<code class="highlighter-rouge">publish</code>)一条信息<code class="highlighter-rouge">hello</code>，这时候A和B会收到这条消息，这就是最简单的发布订阅模式，A和B也可以订阅别的频道，可以接受来自不同频道的信息，注意这里的A和B是长连接，<code class="highlighter-rouge">PUBSUB CHANNELS</code>命令可查看当前活跃的频道。这个功能最典型应用就是<code class="highlighter-rouge">IM</code>系统，广播等场景，但是<code class="highlighter-rouge">redis</code>发布和订阅没有确认的过程，消息发出就没了，不管有没有收到，在实际场景中可能会选择别的方案。</p>

	  ]]></description>
	</item>

	<item>
	  <title>Unix进程间通信(IPC)</title>
	  <link>//UNIX-IPC</link>
	  <author></author>
	  <pubDate>2018-02-20T18:18:00+08:00</pubDate>
	  <guid>//UNIX-IPC</guid>
	  <description><![CDATA[
	     <h3 id="ipc概念">IPC概念:</h3>
<blockquote>
  <p><strong>进程间通信</strong>（<strong>IPC</strong>，<em>Inter-Process Communication</em>），指至少两个<a href="https://zh.wikipedia.org/wiki/%E8%BF%9B%E7%A8%8B">进程</a>或<a href="https://zh.wikipedia.org/wiki/%E7%BA%BF%E7%A8%8B">线程</a>间传送数据或信号的一些技术或方法。进程是<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F">计算机系统</a>分配资源的最小单位(严格说来是线程)。每个进程都有自己的一部分独立的系统资源，彼此是隔离的。为了能使不同的进程互相访问资源并进行协调工作，才有了进程间通信。举一个典型的例子，使用进程间通信的两个应用可以被分类为客户端和服务器（见<strong>主从式架构</strong>），客户端进程请求数据，服务端回复客户端的数据请求。有一些应用本身既是服务器又是客户端，这在<strong>分布式计算</strong>中，时常可以见到。这些<a href="https://zh.wikipedia.org/wiki/%E8%BF%9B%E7%A8%8B">进程</a>可以运行在同一计算机上或网络连接的不同计算机上。</p>

  <p>进程间通信技术包括消息传递、同步、共享内存和<a href="https://zh.wikipedia.org/wiki/%E8%BF%9C%E7%A8%8B%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8">远程过程调用</a>。IPC是一种标准的<a href="https://zh.wikipedia.org/wiki/Unix">Unix</a>通信机制。</p>

  <p>使用IPC 的理由：</p>

  <ul>
    <li>信息共享：<strong>Web服务器</strong>，通过<strong>网页浏览器</strong>使用进程间通信来共享web文件（网页等）和多媒体；</li>
    <li>加速：维基百科使用通过进程间通信进行交流的多服务器来满足用户的请求；</li>
    <li>模块化;</li>
    <li>私有权分离.</li>
  </ul>

  <p>与直接共享内存地址空间的<a href="https://zh.wikipedia.org/wiki/%E5%A4%9A%E7%BA%BF%E7%A8%8B">多线程编程</a>相比，IPC的缺点：[<a href="https://zh.wikipedia.org/wiki/%E8%A1%8C%E7%A8%8B%E9%96%93%E9%80%9A%E8%A8%8A#cite_note-1">1]</a></p>

  <ul>
    <li>采用了某种形式的内核开销，降低了性能;</li>
    <li>几乎大部分IPC都不是程序设计的自然扩展，往往会大大地增加程序的复杂度。</li>
  </ul>
</blockquote>

<h2 id="一管道">一、管道</h2>

<h4 id="1特点">1、特点：</h4>

<ol>
  <li>
    <p>管道是一种半双工的通信方式(即数据只能单向流动)，也有部分系统上实现了全双工的管道，出于程序可移植性考虑，建议使用半双工管道，全双工的通信可由其它方式实现，例如：消息队列，Unix域套接字。</p>
  </li>
  <li>
    <p>管道分为两种，无名管道和有名管道。</p>

    <ul>
      <li><strong>无名管道：</strong></li>
    </ul>

    <p>最早出现的管道是没有名字的，因此只能用于父子进程间通信，父进程通过<code class="highlighter-rouge">fork()</code>系统调用创建一个子进程，然后通过管道通信。</p>

    <ul>
      <li><strong>有名管道(FIFO):</strong></li>
    </ul>

    <p>有名管道也叫<strong>FIFO</strong>，由于磁盘中存在实际的管道文件，前者没有，所以叫有名管道。<code class="highlighter-rouge">FIFO</code>的意思是(first in ,first out)，先进先出。FIFO是一个(单向的)半双工数据流，不同于普通管道的是，每个FIFO都有一个对应文件的路径名与之关联，因此它能完成多个无亲缘关系进程之间的通信。</p>
  </li>
  <li>
    <p>FIFO和无名管道的数据都存在内核的内存缓冲区中，大小一般为一页(4K)。不同的是，FIFO将内核缓冲区的数据映射到了实际的文件节点，可以在磁盘中看到对应的文件，所以叫<strong>有名管道</strong>，而无名管道在磁盘中没有对应文件，因此称<strong>无名管道</strong>。</p>
  </li>
  <li>
    <p>无名管道通过<code class="highlighter-rouge">&lt;unistd.h&gt;</code>头文件中的<code class="highlighter-rouge">pipe()</code>创建，有名管道(FIFO)通过<code class="highlighter-rouge">&lt;sys/stat.h&gt;</code>中的<code class="highlighter-rouge">mkfifo()</code>创建。</p>
  </li>
  <li>
    <p>管道通过<code class="highlighter-rouge">read()</code>和<code class="highlighter-rouge">write()</code>进行读写操作，管道内核缓冲区中的数据一旦被取走，管道中将不存在。当内核缓冲区满的时候，<code class="highlighter-rouge">write()</code>写操作将被阻塞，直到缓冲区有空闲再继续。同理，当缓冲区数据为空时，<code class="highlighter-rouge">read()</code>操作将阻塞，直到有新数据时再返回。</p>
  </li>
  <li>
    <p>当进程终止时，管道就完全被删除了。</p>
  </li>
</ol>

<ul>
  <li>###无名管道</li>
</ul>

<h4 id="1过程">1、过程</h4>

<ol>
  <li>
    <p>创建管道</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;unistd.h&gt;
</span><span class="n">pipe</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> 
</code></pre></div>    </div>
  </li>
  <li>
    <p>通过<code class="highlighter-rouge">fork()</code>创建子进程</p>

    <pre><code class="language-C">// 返回值 &gt;=0:成功 &lt;0:错误
// 如果是父进程则返回子进程 id,子进程则返回 0
fork()
</code></pre>
  </li>
  <li>
    <p><code class="highlighter-rouge">read()</code>和<code class="highlighter-rouge">write()</code>读写缓冲区的数据</p>
  </li>
</ol>

<h4 id="2例子">2、例子</h4>

<ul>
  <li><em>pipe.c</em></li>
</ul>

<pre><code class="language-C">#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;

int main()
{
    int fd[2];	// 管道描述符
    pid_t pid;	// 进程id
    char buff[20];	// 缓冲区长度
    if(pipe(fd) &lt; 0){
        printf("创建管道失败\n");
    }
    pid = fork();	// 创建子进程
    if(pid &lt; 0){
        printf("fork()失败\n");
    }else if (pid &gt; 0){	// 大于0为主进程
        close(fd[0]);	// 关闭主进程读端
        write(fd[1],"hello world\n",12);
    }else{ 	// 小于0为子进程
        close(fd[1]); 	// 关闭子进程写端
        sleep(2);
		read(fd[0], buff, 20);
		printf("读到的数据：%s\n", buff);
    }
    return 0;
}
</code></pre>

<ul>
  <li>
    <h3 id="有名管道fifo">有名管道FIFO</h3>
  </li>
</ul>

<h4 id="1过程-1">1、过程</h4>

<ol>
  <li>按以下示例，先运行<code class="highlighter-rouge">read_fifo.c</code>，创建管道文件(<strong>注意:</strong> 此时管道文件必须不存在，否则会出错)。</li>
  <li>因为此时管道中还没有数据，<code class="highlighter-rouge">read()</code>处于阻塞状态，等待数据。</li>
  <li>再运行<code class="highlighter-rouge">write_fifo.c</code>，向管道中写入数据，此时<code class="highlighter-rouge">read()</code>打印<code class="highlighter-rouge">write_fifo.c</code>写入的数据。</li>
</ol>

<h4 id="2例子-1">2、例子</h4>

<ul>
  <li><em>read_fifo.c</em></li>
</ul>

<pre><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;time.h&gt;
#include &lt;sys/stat.h&gt;

int main()
{
    int fd,len;
    char buff[1024];	//管道缓冲区大小
  if(mkfifo("/Users/meetmax/CWork/fifo1", 0666) &lt; 0)
  {		// 创建FIFO管道,此时`fif01`文件必须不存在，否则报错
    	perror("Create FIFO Failed");
    	exit(1);
  } 
  
	if((fd = open("/Users/meetmax/CWork/fifo1", O_RDONLY)) &lt; 0) 
	{ 	// 以只读模式打开FIFO，和打开普通文件一样
		perror("Open FIFO Failed");
		exit(1);
	}
	 // 如果管道中有数据，读取FIFO管道
	while((len = read(fd, buff, 1024)) &gt; 0)
		printf("Read message: %s", buff);

	close(fd);  // 关闭FIFO文件
	return 0;
}
</code></pre>

<ul>
  <li><em>write_fifo.c</em></li>
</ul>

<pre><code class="language-C">#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;   // exit
#include&lt;fcntl.h&gt;    // O_WRONLY
#include&lt;sys/stat.h&gt;
#include&lt;time.h&gt;     // time
#include &lt;time.h&gt;

int main()
{
	int fd;
	int n, i;
	char buf[1024];
	time_t tp;

	printf("I am %d process.\n", getpid()); // 说明进程ID
	
	if((fd = open("/Users/meetmax/CWork/fifo1", O_WRONLY)) &lt; 0) 
      // 以写打开一个FIFO 
	{
		perror("Open FIFO Failed");
		exit(1);
	}

	for(i=0; i&lt;10; ++i)
	{
		time(&amp;tp);  // 取系统当前时间
		n=sprintf(buf,"Process %d's time is %s",getpid(),ctime(&amp;tp));
		printf("Send message: %s", buf); //	打印
		if(write(fd, buf, n+1) &lt; 0)  // 写入到FIFO中
		{
			perror("Write FIFO Failed");
			close(fd);
			exit(1);
		}
		sleep(1);  // 休眠1秒
	}

	close(fd);  // 关闭FIFO文件
	return 0;
}
</code></pre>

<h2 id="xis-ipc基于system-v-的ipc函数">XIS IPC(基于System V 的IPC函数)</h2>

<p>除管道外，还有3种IPC的进程间的通信，分别为：消息队列、信号量和共享内存。这3个IPC有两种实现方式，分别为基于<strong>System V</strong>和<strong>POSIX</strong>的进程间通信。</p>

<ul>
  <li><em>维基百科</em></li>
</ul>

<p><strong>System V</strong></p>

<blockquote>
  <p><strong>UNIX系统五</strong>[<a href="https://zh.wikipedia.org/wiki/Wikipedia:%E5%88%97%E6%98%8E%E6%9D%A5%E6%BA%90">来源请求]</a>（英语：UNIX System V），是<a href="https://zh.wikipedia.org/wiki/Unix">Unix</a><a href="https://zh.wikipedia.org/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">操作系统</a>众多版本中的一支。它最初由<a href="https://zh.wikipedia.org/wiki/AT%26T">AT&amp;T</a>开发，在1983年第一次发布，因此也被称为<strong>AT&amp;T System V</strong>。</p>
</blockquote>

<p><strong>POSIX</strong></p>

<blockquote>
  <p><strong>可移植操作系统接口</strong>（英语：Portable Operating System Interface，缩写为<strong>POSIX</strong>），是<a href="https://zh.wikipedia.org/wiki/IEEE">IEEE</a>为要在各种<a href="https://zh.wikipedia.org/wiki/UNIX">UNIX</a><a href="https://zh.wikipedia.org/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">操作系统</a>上运行软件，而定义<a href="https://zh.wikipedia.org/wiki/API">API</a>的一系列互相关联的标准的总称，其正式称呼为IEEE Std 1003，而国际标准名称为<a href="https://zh.wikipedia.org/wiki/ISO">ISO</a>/<a href="https://zh.wikipedia.org/wiki/IEC">IEC</a> 9945。</p>
</blockquote>

<p>System V 出现比 POSIX 要早，可以说POSIX是对System V的改进，POSIX API使用比前者更加简单高效，但是为什么两者仍然同时存在呢？还是一个移植性的问题，虽然现在新的程序都基于POSIX标准，但是仍然有很多旧的程序使用了基于System V的IPC，因此两者都保留了。本文的IPC基于System V的IPC函数。</p>

<h2 id="二消息队列">二、消息队列</h2>

<h3 id="1特点-1">1、特点</h3>

<ol>
  <li>消息队列是消息的链表，存储在内核中，由消息队列标识符标识。</li>
  <li>消息队列是随内核持续的，进程终止时，消息队列及其内容不会被删除，除非内核重启或者调用<code class="highlighter-rouge">msgctl()</code>显式的删除消息队列。</li>
  <li>消息队列没有维护引用计数器(打开文件有这种计数器)，所以队列被删除后，仍在使用该队列的进程会出错返回。</li>
</ol>

<h3 id="2过程">2、过程</h3>

<ol>
  <li>先定义消息队列结构<code class="highlighter-rouge">struct msg_form</code>，每条消息都包含：
    <ul>
      <li>消息队列类型：<code class="highlighter-rouge">long</code>类型的<code class="highlighter-rouge">mtype</code></li>
      <li>消息数据：<code class="highlighter-rouge">char *</code>类型的字符串</li>
    </ul>
  </li>
  <li>通过文件的路径名和项目ID(0~255之间)，调用<code class="highlighter-rouge">ftok()</code>获取IPC，获取key值。创建<code class="highlighter-rouge">XSI IPC</code>结构都应指定一个键，这个键的数据类型是系统数据类型key_t，通常在头文件<code class="highlighter-rouge">&lt;sys/types.h&gt;</code>中定义。</li>
  <li>接着调用<code class="highlighter-rouge">msgget()</code>函数，使用key作为其中一个参数，由内核将<code class="highlighter-rouge">key</code>变成IPC的标识符，在这里就是消息队列ID。</li>
  <li>拿到IPC标识符后，通过<code class="highlighter-rouge">msgsnd()</code>和<code class="highlighter-rouge">msgrcv()</code>分别发送和接收消息。</li>
</ol>

<h3 id="3示例">3、示例</h3>

<ul>
  <li><em>msg_client.c</em></li>
</ul>

<pre><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/msg.h&gt;
#include &lt;unistd.h&gt;


#define MSG_FILE "/Users/meetmax/CWork/msg_file"

// 消息结构
struct msg_form {
    long mtype;    
	char mtext[256];
};

int main(){
    int msqid;	// 消息队列id
    key_t key;	// 键值
    struct msg_form msg;

    //获取key值
    if((key = ftok(MSG_FILE,100)) &lt; 0){
        perror("获取key值失败\n");
        exit(0);
    }

    printf("key 值为： %d",key);

    if((msqid = msgget(key,IPC_CREAT|0777)) &lt; 0){
        perror("获取消息队列失败");
        exit(0);
    }
    printf("消息队列id: %d \n",msqid);
    printf("进程id: %d \n",getpid());

    msg.mtype = 888;	// 设置消息类型
    sprintf(msg.mtext,"hello,I'm client %d\n",getpid());
    msgsnd(msqid,&amp;msg,sizeof(msg.mtext),0);

    // 获取777类型的消息
	msgrcv(msqid, &amp;msg, 256, 999, 0);
	printf("Client: receive msg.mtext is: %s.\n", msg.mtext);
	printf("Client: receive msg.mtype is: %ld.\n", msg.mtype);
	return 0;
}
</code></pre>

<ul>
  <li><em>msg_server.c</em></li>
</ul>

<pre><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/msg.h&gt;
#include &lt;unistd.h&gt;

#define MSG_FILE "/Users/meetmax/CWork/msg_file"
struct msg_form{
    long mtype;
    char mtext[256];
};
int main()
{
    int msqid;
    key_t key;
    struct msg_form msg;
    //获取key值
    if((key = ftok(MSG_FILE,100)) &lt; 0){
        perror("获取key失败");
        exit(1);
    }
    //打印key值
    printf("key的值为 %d \n",key);
    //根据key值创建消息队列
    if((msqid = msgget(key,IPC_CREAT|0777)) &lt; 0){
        perror("创建消息队列失败");
        exit(1);
    }
    printf("消息队列id为 : %d \n",msqid);
    printf("进程id为 : %d \n",getpid());
    while(1)
    {
        //接受888类型的消息        
        msgrcv(msqid,&amp;msg,256,888,0);
        printf("Server:receive msg.mtext: %s \n",msg.mtext);
        printf("Server:receive msg.xxx: %ld \n",msg.mtype);
        msg.mtype = 999;
        sprintf(msg.mtext,"hello I'm server: %d \n",getpid());
        //发送消息
        msgsnd(msqid,&amp;msg,sizeof(msg.mtext),0);
    }
    return 0;
}
</code></pre>

<h2 id="三信号量">三、信号量</h2>

<h3 id="1特点-2">1、特点</h3>

<ol>
  <li>
    <p>信号量类似锁机制，能够使临界区内的资源在某一时刻只能被一个进程访问。临界区是指多个进程或线程共享的内存空间，在访问临界区的时候，多个进程操作同一个资源，此时就存在竞态条件，通常在两个进程对同一个资源写操作时，会产生结果不一致的问题，因为我们不知道系统进程何时切换，这种情况也很难复现和调试。必须有一种机制来保证在同一时刻只能有一个进程访问临界区，信号量就提供了这种机制。</p>
  </li>
  <li>
    <p>信号量是一种特殊的变量，程序对它的访问都是<strong>原子操作</strong>，所谓原子操作，即是指不可被中断的操作，要实现原子操作单纯软件是不够的。虽然也能实现，但是效率很低，信号量是一种和硬件紧密结合的机制，它不会被系统进程切换和中断操作打断。本文以<strong>二值信号量</strong>为例子，二值信号量能实现互斥锁的功能，保证同一时间只能一个进程访问资源。</p>
  </li>
  <li>
    <p>信号量的P,V操作</p>

    <p><em>来自维基百科</em></p>
  </li>
</ol>

<blockquote>
  <p>计数信号量具备两种操作动作，之前称为 V（又称signal()）与 P（wait()）。 V操作会增加信号量 S的数值，P操作会减少它。</p>

  <p>运作方式：</p>

  <ol>
    <li>初始化，给与它一个非负数的整数值。</li>
    <li>运行 P（wait()），信号量S的值将被减少。企图进入<a href="https://zh.wikipedia.org/wiki/%E8%87%A8%E7%95%8C%E5%8D%80%E6%AE%B5">临界区块</a>的进程，需要先运行 P（wait()）。当信号量S减为负值时，进程会被挡住，不能继续；当信号量S不为负值时，进程可以获准进入临界区块。</li>
    <li>运行 V（又称signal()），信号量S的值会被增加。结束离开<a href="https://zh.wikipedia.org/wiki/%E8%87%A8%E7%95%8C%E5%8D%80%E6%AE%B5">临界区块</a>的进程，将会运行 V（又称signal()）。当信号量S不为负值时，先前被挡住的其他进程，将可获准进入<a href="https://zh.wikipedia.org/wiki/%E8%87%A8%E7%95%8C%E5%8D%80%E6%AE%B5">临界区块</a>。</li>
  </ol>
</blockquote>

<h3 id="2过程-1">2、过程</h3>

<ol>
  <li>获取<code class="highlighter-rouge">key</code>值(同消息队列)</li>
  <li>获取信号量ID(同消息队列)</li>
  <li><code class="highlighter-rouge">semctl()</code>函数初始化信号量</li>
  <li><code class="highlighter-rouge">fork()</code>子进程</li>
  <li>执行P,V操作</li>
</ol>

<h3 id="3例子">3、例子</h3>

<p><em>sem.c 二值信号量</em></p>

<pre><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/sem.h&gt; // 信号量函数库
#include &lt;unistd.h&gt;

#define SEM_FILE "/Users/meetmax/CWork/sem_file" // 信号量文件

union sem_union //信号量联合
{
    int val;
    struct semid_ds *buf;
    unsigned short *array;
};

//初始化信号量
int init_sem(int sem_id,int val)
{
    union sem_union tmp;
    tmp.val = val;
    if((semctl(sem_id,0,SETVAL,tmp)) == -1)
    {
        perror("初始化信号量失败");
        return -1;
    }
    return 0;
}

/**
 * P操作
 * 信号量大于0时执行 -1 操作，获取资源
 * 若信号量 &lt;= 0 则挂起等待
*/
int sem_p(int sem_id)
{
    struct sembuf sbuf;
    sbuf.sem_num = 0;
    sbuf.sem_op = -1;
    sbuf.sem_flg = SEM_UNDO;
    if(semop(sem_id,&amp;sbuf,1) == -1)
    {
        perror("p操作失败");
        return -1;
    }
    return 0;
}

/**
 * V操作
 * 信号量 &lt;= 0时执行，+1操作，释放资源
 * 若信号量 &gt; 0 时挂起等待
 */
int sem_v(int sem_id)
{
    struct sembuf sbuf;
    sbuf.sem_num = 0;
    sbuf.sem_op = 1;
    sbuf.sem_flg = SEM_UNDO;
    if(semop(sem_id,&amp;sbuf,1) == -1)
    {
        perror("V操作失败");
        return -1;
    }
    return 0;
}

//删除信号量
int sem_del(int sem_id)
{
    union sem_union tmp;
    if(semctl(sem_id,0,IPC_RMID,tmp) == -1)
    {
        perror("删除信号量失败");
        return -1;
    }
    return 0;
}

int main()
{
    int sem_id;
    key_t key;
    pid_t pid;

    //获取key值
    if((key = ftok(SEM_FILE,100)) == -1)
    {
        perror("获取key值失败");
        exit(1);
    }
    //获取信号量id
    if((sem_id = semget(key,1,IPC_CREAT|0666)) == -1)
    {
        perror("信号量id获取失败");
        exit(1);
    }

    //初始化信号量
    init_sem(sem_id,0);

    //fork进程
    if((pid = fork()) == -1)
    {
        perror("进程fork失败");
        exit(1);
    }else if(pid == 0){ //子进程
        printf("我是子进程：%d \n",getpid());
        sleep(2);
        sem_v(sem_id);
    }else if(pid &gt; 0){ //父进程
        sem_p(sem_id);
        printf("我是父进程：%d \n",getpid());
        sem_v(sem_id);
        sem_del(sem_id);
    }
    return 0;
}
</code></pre>

<h2 id="四共享内存">四、共享内存</h2>

<h3 id="1特点-3">1、特点</h3>

<p><em>概念</em></p>

<blockquote>
  <p>顾名思义，共享内存就是允许两个不相关的进程访问同一个逻辑内存。共享内存是在两个正在运行的进程之间共享和传递数据的一种非常有效的方式。不同进程之间共享的内存通常安排为同一段物理内存。进程可以将同一段共享内存连接到它们自己的地址空间中，所有进程都可以访问共享内存中的地址，就好像它们是由用C语言函数malloc分配的内存一样。而如果某个进程向共享内存写入数据，所做的改动将立即影响到可以访问同一段共享内存的任何其他进程。</p>
</blockquote>

<h3 id="2过程-2">2、过程</h3>

<ol>
  <li><code class="highlighter-rouge">ftko()</code>获取key值(同消息队列)</li>
  <li>用<code class="highlighter-rouge">shmget()</code>函数获取共享内存ID</li>
  <li>进程通过<code class="highlighter-rouge">shmat()</code>函数连接共享内存</li>
  <li>访问共享内存</li>
</ol>

<h3 id="3示例-1">3、示例</h3>

<p><em>shm_server.c 读数据</em></p>

<pre><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/shm.h&gt;
#include &lt;string.h&gt;

#define SHM_FILE "/Users/meetmax/CWork/shm_file"

int main()
{
    int shm_id;
    key_t key;
    char * shm;
    struct shmid_ds buf;
	// 获取key
    if((key = ftok(SHM_FILE,100)) == -1)
    {
        perror("获取key失败");
        exit(0);
    }
	// 获取共享内存描述符ID
    if((shm_id = shmget(key,512,IPC_CREAT|0666)) == -1)
    {
        perror("获取共享内存id失败");
        exit(0);
    }
	// 连接共享内存
    if((int)(shm = (char *)shmat(shm_id,0,0)) == -1)
    {
        perror("连接共享内存失败");
        exit(1);
    }
    printf("开始接收数据\n");
  
    // 开始忙等，接收数据
    while(1)
    {
        if(strlen(shm) &gt; 0){
            printf("收到数据：%s \n",shm);
            sprintf(shm,"");
        }
        if(strcmp(shm,"r") == 0){
            printf("已退出\n");
            break;
        }
    }
    // 删除共享内存
    shmctl(shm_id,IPC_RMID,&amp;buf);
    return 0;

}
</code></pre>

<p><em>sem_client.c 写入数据</em></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/shm.h&gt;
</span>
<span class="cp">#define SHM_FILE "/Users/meetmax/CWork/shm_file"
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">shm_id</span><span class="p">;</span>
    <span class="n">key_t</span> <span class="n">key</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span> <span class="n">shm</span><span class="p">;</span>
   
	<span class="c1">// 获取key
</span>    <span class="k">if</span><span class="p">((</span><span class="n">key</span> <span class="o">=</span> <span class="n">ftok</span><span class="p">(</span><span class="n">SHM_FILE</span><span class="p">,</span><span class="mi">100</span><span class="p">))</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">"获取key失败"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>
	<span class="c1">// 获取共享内存id
</span>    <span class="k">if</span><span class="p">((</span><span class="n">shm_id</span> <span class="o">=</span> <span class="n">shmget</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="mi">512</span><span class="p">,</span><span class="n">IPC_CREAT</span><span class="o">|</span><span class="mo">0666</span><span class="p">))</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">"获取共享内存id失败"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>
	<span class="c1">// 连接共享内存，若不存在则创建
</span>    <span class="k">if</span><span class="p">((</span><span class="kt">int</span><span class="p">)(</span><span class="n">shm</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">shmat</span><span class="p">(</span><span class="n">shm_id</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>   
    <span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">"连接共享内存失败"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"请输入："</span><span class="p">);</span>
    <span class="n">scanf</span><span class="p">(</span><span class="s">"%s"</span><span class="p">,</span><span class="n">shm</span><span class="p">);</span> <span class="c1">// 写入数据到共享内存
</span>    <span class="n">shmdt</span><span class="p">(</span><span class="n">shm</span><span class="p">);</span> <span class="c1">// 断开连接
</span>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="参考">参考</h2>

<ul>
  <li><em>《UNIX环境高级编程》</em></li>
  <li><em>《UNIX网络编程：卷2》</em></li>
  <li>部分来自互联网</li>
</ul>

	  ]]></description>
	</item>


</channel>
</rss>
