<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>meetmax.cn</title>
   
   <link></link>
   <description>Stay Hungry , Stay Foolish</description>
   <language>en-uk</language>
   <managingEditor> </managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>Java学习笔记(七) - 接口</title>
	  <link>//Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%83)-%E6%8E%A5%E5%8F%A3</link>
	  <author></author>
	  <pubDate>2018-09-11T00:00:00+08:00</pubDate>
	  <guid>//Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%83)-%E6%8E%A5%E5%8F%A3</guid>
	  <description><![CDATA[
	     <h2 id="一-接口">一. 接口</h2>
<h3 id="1-概念">1. 概念</h3>
<p>广义上的接口指的是一种标准，一种约定，只要遵守这个约定，大家就可以协作实现特定的功能。比如非常流行的<code>USB接口</code>，几乎所有电脑厂商都使用了这个标准，U盘厂商只要按着这个标准做，就可以和电脑实现数据传输，同理，鼠标厂商只要实现了<code>USB接口</code>，鼠标就可以连接到电脑。<br />
  Java的接口的概念也类似，首先声明一个接口，使用<code>Interface</code>关键词，在接口<code>{}</code>体内可以声明抽象的方法，接着任何类都可以通过<code>implements</code>实现它，前提是这个类必须实现接口内定义的方法。</p>

<h3 id="2-定义接口">2. 定义接口</h3>
<p>一个接口的声明由<strong>修饰符</strong>，<strong>interface关键词</strong>，<strong>接口名称</strong>，<strong>父级接口(用逗号分隔)</strong>，<strong>大括号{}</strong>。例如：</p>

<pre><code class="language-java">public interface GroupedInterface extends Interface1, Interface2, Interface3 {
    // constant declarations
    // base of natural logarithms
    double E = 2.718282;
 
    // method signatures
    void doSomething (int i, double x);
    int doSomethingElse(String s);
}// constant declarations    
</code></pre>

<p>需要注意的是接口声明不能使用<code>private</code>和<code>protected</code>关键词，这点和类的声明不同，<code>public</code>关键词可以在任何<em>包</em>内使用，也可以使用默认的，即不使用修饰符，它的使用范围是在同一个包内，即<em>包私有</em>。<br />
  接口体中可以包含<em>抽象方法</em>，<em>默认方法</em>和<em>静态方法</em>。接口中声明的所有方法包括(抽象方法，默认方法和静态方法)都是隐式的<code>public</code>关键词，而且只能是<code>public</code>类型，所以声明方法的时候可以省略<code>public</code>修饰符。<br />
  另外，接口中可以声明常量，在接口中声明常量，默认都是<code>public</code>,<code>static</code>和<code>final</code>，同样的，可以省略这些关键词。</p>

<h3 id="3-实现接口">3. 实现接口</h3>
<p>声明一个实现接口的类，需要在类声明中包含一个<code>implements</code>关键词，一个类可以实现多个接口，接口之间通过<code>,</code>逗号隔开，<code>implements</code>关键词跟在<code>extends</code>子句之后。下面是<code>Relatable</code>接口的声明：</p>

<pre><code class="language-java">public interface Relatable {   
   // this (object calling isLargerThan)
   // and other must be instances of 
   // the same class returns 1, 0, -1 
   // if this is greater than, 
   // equal to, or less than other
   public int isLargerThan(Relatable other);
}
</code></pre>

<p>如果一个类要实现<code>Relatable</code>接口，必须实现<code>isLargerThan</code>方法，在例子中省略了方法具体的过程，如下：</p>

<pre><code class="language-java">public class RectanglePlus implements Relatable {
    // a method required to implement
    // the Relatable interface
    public int isLargerThan() {
		return 0;
    }
}
</code></pre>

<p>另外，也可以把接口作为类型使用，只要实现了<code>Relatable</code>接口的类的实例都是<code>Relatable</code>类型，且可以调用接口方法<code>isLargerThan</code></p>

<pre><code class="language-java">Relatable rectanglePlus = new RectanglePlus();
int number = rectanglePlus.isLargerThan();
</code></pre>

<h3 id="4-接口使用技巧">4. 接口使用技巧</h3>
<p>现在有一个定义好的接口，其中有两个抽象方法，如下：</p>

<pre><code class="language-java">public interface DoIt {
   void doSomething(int i, double x);
   int doSomethingElse(String s);
}
</code></pre>

<p>假设再过了一段时间，我们又想加一个方法<code>didItWork</code>,那么接口可以改成如下：</p>

<pre><code class="language-java">public interface DoIt {

   void doSomething(int i, double x);
   int doSomethingElse(String s);
   boolean didItWork(int i, double x, String s);
   
}
</code></pre>

<p>如果这样改变，那么实现了这个接口所有类都必须同时实现<code>didItWork</code>，需要对所有实现了<code>DoIt</code>接口的类进行修改，这样会带来很多不必要的错误。<br />
  在定义接口时尽量想的周全一些，保证在未来很长一段时间内不需要修改接口。如果遇到一些意料之外的情况，比如需求变更，必须要在原有接口上增加方法，你可以选择扩展<code>DoIt</code>接口，重新定义一个接口<code>DoItPlus</code>，把需要添加的方法加到<code>DoItPlus</code>接口内，且<code>DoItPlus</code>继承<code>DoIt</code>，如下：</p>

<pre><code class="language-java">public interface DoItPlus extends DoIt {

   boolean didItWork(int i, double x, String s);
   
}
</code></pre>

<p>这样做有个很明显的好处，老接口仍然可以照常使用，不需要修改实现了<code>DoIt</code>的类，想使用新接口的类可以升级到<code>DoItPlus</code>接口，只需要修改部分类即可。
  另外，接口中也可以使用<em>默认方法</em>和<em>静态方法</em>，它们的特点是不需要在实现类中重新实现他们，要注意的是<em>默认方法</em>和<em>静态方法</em>都不能是抽象方法，必须是具体实现的方法，<em>默认方法</em>可以在子类中直接使用，下面定义了<code>didItWork</code>的默认方法。</p>

<pre><code class="language-java">public interface DoIt {
   void doSomething(int i, double x);
   int doSomethingElse(String s);
   default boolean didItWork(int i, double x, String s) {
       // Method body 
   }
   
}
</code></pre>

<h3 id="5-默认方法和静态方法">5. 默认方法和静态方法</h3>
<h4 id="默认方法">默认方法</h4>
<p>根据上面的例子我们知道，<em>默认方法</em>可以在不修改实现类的情况下，实现对现有接口的扩展，<em>默认方法</em>是以关键词<code>default</code>作为方法前面的开头，<em>默认方法</em>是隐式的<code>public</code>修饰符，所以可以省略<code>public</code>关键词，默认方法可以直接被实现类的实例使用，如下所示声明了<code>TimeClient</code>接口，其中包含默认方法<code>getZonedDateTime</code></p>

<pre><code class="language-java">package defaultmethods;
 
import java.time.*;

public interface TimeClient {
    void setTime(int hour, int minute, int second);
    void setDate(int day, int month, int year);
    void setDateAndTime(int day, int month, int year,
                               int hour, int minute, int second);
    LocalDateTime getLocalDateTime();
    
    static ZoneId getZoneId (String zoneString) {
        try {
            return ZoneId.of(zoneString);
        } catch (DateTimeException e) {
            System.err.println("Invalid time zone: " + zoneString +
                "; using default time zone instead.");
            return ZoneId.systemDefault();
        }
    }
        
    default ZonedDateTime getZonedDateTime(String zoneString) {
        return ZonedDateTime.of(getLocalDateTime(), getZoneId(zoneString));
    }
}
</code></pre>

<p>类<code>SimpleTimeClient</code>实现了<code>TimeClient</code>接口，使用实现类的实例调用默认方法：</p>

<pre><code class="language-java">package defaultmethods;
 import java.time.*;
import java.lang.*;
import java.util.*;

public class TestSimpleTimeClient {
    public static void main(String... args) {
        TimeClient myTimeClient = new SimpleTimeClient();
        System.out.println("Current time: " + myTimeClient.toString());
        System.out.println("Time in California: " +
            myTimeClient.getZonedDateTime("Blah blah").toString());
    }
}
</code></pre>

<p>当你在扩展包含<em>默认方法</em>的接口时，你可以做如下选择：</p>

<ul>
  <li>不涉及默认方法，扩展接口将继承父级接口的默认方法。</li>
  <li>重新定义默认方法，使它变成抽象方法。</li>
  <li>重新定义该默认方法，也就是重写它。</li>
</ul>

<h4 id="静态方法">静态方法</h4>
<p>除了默认方法，你也可以在接口中定义静态方法。一个静态方法是和类关联的，它不与任何对象关联，该类的每个实例都共享其静态方法，它很适用于在库中作为辅助方法，可以在接口中定义针对接口的静态方法，不需要针对单独的类去定义方法。上面的例子中定义了<code>getZoneId</code>静态方法，以<code>static</code>关键词开头的方法签名，隐式的<code>public</code>修饰符，因此可以省略<code>public</code>关键词。</p>

<h2 id="参考">参考</h2>
<p><a href="https://docs.oracle.com/javase/tutorial/java/IandI/createinterface.html">The Java™ Tutorials</a></p>

	  ]]></description>
	</item>

	<item>
	  <title>Java学习笔记(六) - 注解</title>
	  <link>//Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E5%85%AD)-%E6%B3%A8%E8%A7%A3</link>
	  <author></author>
	  <pubDate>2018-09-09T00:00:00+08:00</pubDate>
	  <guid>//Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E5%85%AD)-%E6%B3%A8%E8%A7%A3</guid>
	  <description><![CDATA[
	     <h2 id="一概念">一、概念</h2>
<p>注解是一种形式的元数据，为程序本身提供额外的数据，注解本身对程序没有直接影响，越来越多的框架使用了<strong>注解</strong>，如<code>Spring Boot</code>，使用<code>@Autowired</code>注解，结合反射机制实现依赖注入，还有基于注解自动载入<code>XML</code>配置。注解有很多用途，包括以下：</p>

<ul>
  <li>为编译器提供信息 —— 编译器可以根据注解检测出错误或抑制某些警告。</li>
  <li>编译时和部署时处理 —— 一些软件工具可根据注解提供的信息生成相关代码，XML文件等等。</li>
  <li>运行时处理 —— <code>Spring Boot</code>框架通过<code>@Autowired</code>注解提供的信息，再通过反射实现依赖注入 。</li>
</ul>

<h2 id="二注解基础">二、注解基础</h2>
<p>注解通过<code>@</code>符号告诉编译器这是一个注解，最常见的注解是<code>@Override</code>(重写注解)，它一般应用在子类的方法声明上，用来告诉编译器这是一个重写方法，如果在父类中没有声明与之相同的方法，则无法通过编译。虽然在重写方法时不使用<code>@Override</code>注解仍然可以达到重写的效果，但是使用了该注解可以避免一些不必要的错误，且在编译时就可以检测出来。</p>

<pre><code class="language-java">@Override
void mySuperMethod() { ... }
</code></pre>

<p>注解可以包含一些参数，如下的<code>@Author</code>注解，可自定义<code>name</code>和<code>date</code>参数，当注解中只有一个参数时，可以省略参数名称。</p>

<pre><code class="language-java">@Author(
   name = "Benjamin Franklin",
   date = "3/27/2003"
)
class MyClass() { ... }


@Author("Benjamin Franklin")
class MyClass() { ... }
</code></pre>

<p>在同一个方法声明中，也可以包含多个注解，在Java8之后，甚至可以包含重复的注解。如下：</p>

<pre><code class="language-java">@Override
@Author("Benjamin Franklin")
@Author("Benjamin Franklin2")
class MyClass() { ... }
</code></pre>

<p>注解不仅可以用在方法声明中，也可以用在<code>字段</code>和<code>类</code>的声明中，在Java8之后，注解也可以当作类型使用，如下所示，这种形式的注解被称为<code>类型注解</code>，更多关于类型注解请看下面。</p>

<pre><code class="language-java">new @Interned MyObject();
</code></pre>

<h2 id="三注解的声明">三、注解的声明</h2>
<p>注解声明的语法类似接口，通过<code>@interface</code>关键词声明一个注解类型，注解可以理解成一种特殊的形式的接口，下面声明了一个关于<em>文章信息</em>的注解，在<code>{}</code>大括号内包含了<code>注解元素</code>的声明，且元素可以定义一个可选的默认值，在<code>default</code>关键词之后。</p>

<pre><code class="language-java">@interface ArticleInfo {
   String author();
   String date();
   int currentRevision() default 1;
   String lastModified() default "N/A";
   String lastModifiedBy() default "N/A";
   // Note use of array
   String[] reviewers();
}
</code></pre>

<p>注解元素的数据类型支持：</p>
<ul>
  <li>基本数据类型 (int,float,boolean,byte,double,char,long,short)</li>
  <li>String 类型</li>
  <li>enum类型</li>
  <li>Class 类型</li>
  <li>Annotation类型</li>
  <li>以上所有类型的数组</li>
</ul>

<h2 id="四预定义的注解">四、预定义的注解</h2>
<p>预定义注解分为2种类型，一种是直接被Java语言使用的注解，另一种用来注解其它的注解，被称为<strong>元注解</strong>。</p>
<h3 id="1-java语言使用的注解">1. Java语言使用的注解</h3>
<p>Java语言使用的预定义注解有3种类型，分别是<code>@Deprecated</code>，<code>@Override</code>，<code>@SuppressWarnings</code>。</p>

<ul>
  <li><strong>@Deprecated</strong> —— 该注解表示，被标记的代码已经弃用了或者很久没有被使用了，不建议使用这段代码。</li>
  <li><strong>@Override</strong> —— 该注解表示，该方法是一个重写方法，如果父类中没有相同的方法，代码将不能通过编译。</li>
  <li><strong>@SuppressWarnings</strong> —— 用于压制编译器的相关警告</li>
</ul>

<h3 id="2-元注解">2. 元注解</h3>
<p>被用于声明其它注解的注解叫<strong>元注解</strong>，在<code>java.lang.annotation</code>包中有一些被定义的元注解。<br />
<strong>@Retention</strong> 注解指定了注解的存储级别。</p>
<ul>
  <li><em>RetentionPolicy.SOURCE</em>  - 该标记表示注解仅被存储在源码级别，忽略编译器。</li>
  <li><em>RetentionPolicy.CLASS</em> - 该标记表示注解仅被保留在编译时，对<code>JVM</code>虚拟机忽略。</li>
  <li><em>RetentionPolicy.RUNTIME</em> - 该标记表示注解被保留在<code>JVM</code>运行时中，在运行时中仍然可获取到注解信息。</li>
</ul>

<p><strong>@Documented</strong> - 文档注解，使用了该注解可被<code>java doc</code>工具记录下来，默认是不记录的。</p>

<p><strong>@Target</strong> 注解用来注解另一注解，限制该注解可用于哪种类型的Java元素，例如：</p>
<ul>
  <li><em>ElementType.ANNOTATION_TYPE</em> - 用于声明其它注解的注解</li>
  <li><em>ElementType.CONSTRUCTOR</em> - 用于构造器的注解</li>
  <li><em>ElementType.FIELD</em> - 用于成员变量的注解</li>
  <li><em>ElementType.LOCAL_VARIABLE</em> - 用于局部变量的注解</li>
  <li><em>ElementType.METHOD</em> - 用于方法的注解</li>
  <li><em>ElementType.PACKAGE</em> - 用于包的注解</li>
  <li><em>ElementType.PARAMETER</em> - 用于方法参数的注解</li>
  <li><em>ElementType.TYPE</em> - 用于 类、枚举、接口、注解</li>
</ul>

<p><strong>@Inherited</strong>  - 该注解用于标记注解，被<code>@Inherited</code>标记的注解，该注解能够被子类继承，要注意，该特性仅在用于类的注解时有效，标记其它是无效的。
例如有2个注解：</p>

<pre><code class="language-java">@Inherited
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface InheritedAnnotationType {

}

@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface UninheritedAnnotationType {

}
</code></pre>

<p>有3个类</p>

<pre><code class="language-java">@UninheritedAnnotationType
class A {

}

@InheritedAnnotationType
class B extends A {

}

class C extends B {

}
</code></pre>

<p>此时B类没有继承A类中的<code>@UninheritedAnnotationType</code>注解，因为<code>@UninheritedAnnotationType</code>注解没有被<code>@Inherited</code>标记，C类中继承了B类中的<code>@InheritedAnnotationType</code>注解，因为它被<code>@Inherited</code>元注解标记了。</p>

<p>运行下面的代码:</p>

<pre><code class="language-java">System.out.println(new A().getClass().getAnnotation(InheritedAnnotationType.class));
System.out.println(new B().getClass().getAnnotation(InheritedAnnotationType.class));
System.out.println(new C().getClass().getAnnotation(InheritedAnnotationType.class));
System.out.println("_________________________________");
System.out.println(new A().getClass().getAnnotation(UninheritedAnnotationType.class));
System.out.println(new B().getClass().getAnnotation(UninheritedAnnotationType.class));
System.out.println(new C().getClass().getAnnotation(UninheritedAnnotationType.class));
</code></pre>

<p>得到运行结果</p>

<pre><code class="language-java">null
@InheritedAnnotationType()
@InheritedAnnotationType()
_________________________________
@UninheritedAnnotationType()
null
null
</code></pre>
<p>以上例子来自 <a href="https://stackoverflow.com/questions/23973107/how-to-use-inherited-annotation-in-java">How to use @inherited annotation in Java?</a></p>

<p><strong>@Repeatable</strong> 该注解在Java8中才被定义，被该注解标记的注解可用于重复注解，关于重复注解，详细请看下面。</p>

<h2 id="五重复注解">五、重复注解</h2>
<p>重复注解是Java8的新特性，允许你在一个元素上使用多个相同的注解标记，不过对于这个注解本身有一些要求，该注解必须被<code>@Repeatable</code>元注解标记，下面是声明一个可重复的注解的步骤。</p>

<ol>
  <li>声明一个重复注解</li>
</ol>

<pre><code class="language-java">import java.lang.annotation.Repeatable;

@Repeatable(Schedules.class)
public @interface Schedule {
  String dayOfMonth() default "first";
  String dayOfWeek() default "Mon";
  int hour() default 12;
}
</code></pre>

<ol>
  <li>声明一个注解容器
注解容器是用来存放重复注解的容器，必须有一个数组的值，且该数组类型必须和上面声明重复注解的类型一样，在本例中即<code>Schedule</code>类型。以下为声明步骤：</li>
</ol>

<pre><code class="language-java">public @interface Schedules {
    Schedule[] value();
}
</code></pre>

<h2 id="六参考">六、参考</h2>
<p><a href="https://docs.oracle.com/javase/tutorial/java/annotations/index.html">The Java™ Tutorials</a></p>


	  ]]></description>
	</item>

	<item>
	  <title>Java学习笔记(五) - 访问控制</title>
	  <link>//Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%94)-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6</link>
	  <author></author>
	  <pubDate>2018-09-01T00:00:00+08:00</pubDate>
	  <guid>//Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%94)-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6</guid>
	  <description><![CDATA[
	     <h2 id="访问级别修饰符">访问级别修饰符</h2>
<p>一个类的成员变量或方法是否能被其它类访问到取决于访问级别的修饰符，Java有四种级别的访问修饰符，分别是<code>public</code>,<code>protected</code>,<code>package-private</code>(没有修饰符)，<code>private</code>，访问级别逐级降低。</p>

<p>下表表示每个修饰符的访问权限。</p>

<table>
  <thead>
    <tr>
      <th>Modifier</th>
      <th>Class</th>
      <th>Package</th>
      <th>Subclass</th>
      <th>World</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>public</td>
      <td>Y</td>
      <td>Y</td>
      <td>Y</td>
      <td>Y</td>
    </tr>
    <tr>
      <td>protected</td>
      <td>Y</td>
      <td>Y</td>
      <td>Y</td>
      <td>N</td>
    </tr>
    <tr>
      <td>no modifier</td>
      <td>Y</td>
      <td>Y</td>
      <td>N</td>
      <td>N</td>
    </tr>
    <tr>
      <td>protected</td>
      <td>Y</td>
      <td>N</td>
      <td>N</td>
      <td>N</td>
    </tr>
  </tbody>
</table>

<p>第一列表示类成员在类的内部是否能被访问，第二列表示类成员在同一个包内的不同类的是否能把访问到，第三列表上类成员在包外部的子类是否能访问到，第四列表示类成员是否能被任意包的任意类访问到，是最高的访问权限。
在成员不加访问修饰符的情况下，该成员的访问级别是<code>package-private</code>。</p>

<h2 id="访问级别的选择">访问级别的选择</h2>
<ul>
  <li>我们应该尽量选择最严格的访问权限控制符，在能用<code>private</code>的时候就不要用<code>public</code>，除非真的有特别的需要，这样可以避免一些滥用成员的错误。</li>
  <li>尽量避免使用<code>public</code>修饰符，除非该成员是常量，即使用了<code>final</code>修饰符。</li>
</ul>

<h2 id="参考">参考</h2>
<p><a href="https://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html">The Java™ Tutorials</a></p>

	  ]]></description>
	</item>

	<item>
	  <title>Java学习笔记(四) - 类</title>
	  <link>//Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E5%9B%9B)-%E7%B1%BB</link>
	  <author></author>
	  <pubDate>2018-08-28T00:00:00+08:00</pubDate>
	  <guid>//Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E5%9B%9B)-%E7%B1%BB</guid>
	  <description><![CDATA[
	     <h2 id="声明类">声明类</h2>
<p>Java的类可以通过<code>class</code>关键词，<code>{}</code>大括号来声明，在<code>{}</code>大括号中间是类的<code>body</code>体，在<code>body</code>体内可声明成员变量、方法和构造函数等等。另外，也可以在<code>class</code>前面加上修饰符<code>private</code>或<code>public</code>，修饰符的作用是访问控制，前者说明该类是私有类，其它类不能访问它，后者是公开的，任何类都可以访问它，下面是公开类的声明示例。</p>

<pre><code class="language-java">public class Myclass {
	// 这里可以声明成员变量
	// 方法、构造函数等
}
</code></pre>

<p>上面是一个简单类的声明，类还可通过关键词<code>extends</code>继承其它类，通过关键词<code>implements</code>继承多个接口，例如：</p>

<pre><code class="language-java">class MyClass extends MySuperClass implements YourInterface,YourInterface2 {
    // field, constructor, and
    // method declarations
}
</code></pre>

<p>通常，类的声明包含以下几个部分：</p>

<ol>
  <li>修饰符，例如<code>public</code>，<code>private</code>，<code>protected</code>等。</li>
  <li>类的名称，按照规范，类名首字母大写(非必须)，增加可读性</li>
  <li>可通过关键词<code>extends</code>继承<code>超类</code>，且只能继承一个<code>超类</code>，Java不支持多继承</li>
  <li>可通过关键词<code>implements</code>继承接口，Java接口支持多继承，接口之间用<code>,</code>逗号分隔。</li>
  <li>类的<code>body</code>体，在<code>{}</code>大括号之间。</li>
</ol>

<h2 id="声明成员变量">声明成员变量</h2>
<p>成员变量是指在类的内部，且不在<code>方法</code><code>块</code>内，且不是方法的参数，下面是声明成员变量的示例：</p>

<pre><code class="language-java">public class Myclass {
	public String hello;
}
</code></pre>

<p>上面的代码中，<code>hello</code>就是一个公开的，<code>String</code>类型的成员变量，成员变量一般由以下3部分组成：</p>

<ol>
  <li>0或多个修饰符，例如<code>private</code>或<code>public</code></li>
  <li>字段类型</li>
  <li>字段名称</li>
</ol>

<h2 id="方法声明">方法声明</h2>

<p>下面是一个方法声明的例子：</p>

<pre><code class="language-java">
public class Myclass {
	public double calculateAnswer(double wingSpan, int numberOfEngines,double length, double grossTons) {
    //do the calculation here
	}
}
</code></pre>
<p>方法声明由以下6部分组成:</p>
<ol>
  <li>修饰符-例如<code>public</code>,<code>private</code></li>
  <li>返回值的类型，如果没有返回值则声明为<code>void</code></li>
  <li>方法名</li>
  <li>方法的参数，在<code>()</code>内声明，多个参数之间用<code>,</code>逗号隔开，如果没有参数，就是用空的<code>()</code></li>
  <li>一个异常列表</li>
  <li>方法的<code>body</code>，在<code>{}</code>之间包含了方法代码和局部变量等。</li>
</ol>

<h3 id="方法签名">方法签名</h3>
<p><strong>方法签名</strong> 包括方法名称和参数类型，在上面代码中，它的方法签名是</p>

<pre><code class="language-java">calculateAnswer(double, int, double, double)
</code></pre>

<h3 id="方法重载">方法重载</h3>
<p>在同一个类里可以有相同名称的方法，只要它们的方法签名不同，Java编译器可以根据方法签名判断出你要调用的具体方法，例如：</p>

<pre><code class="language-java">public class DataArtist {
    ...
    public void draw(String s) {
        ...
    }
    public void draw(int i) {
        ...
    }
    public void draw(double f) {
        ...
    }
    public void draw(int i, double f) {
        ...
    }
}
</code></pre>

<p>上面代码中有4个名为<code>draw</code>的方法，在调用的时候，Java编译器可根据参数类型区分出调用的是哪个方法，在同一个类中不能声明具有相同名称、相同的参数数量和相同参数类型的方法，即使他们返回类型不一样，因为Java编译器无法识别出调用的是哪个方法。</p>

<h2 id="类的构造函数">类的构造函数</h2>
<p>每个类都包含构造函数，构造函数在创建对象时被调用，构造函数的声明和方法的声明很像，除了构造函数没有返回值，且函数名必须和类名一样。例如<code>Bicycle</code>类有一个构造函数</p>

<pre><code class="language-java">public Bicycle(int startCadence, int startSpeed, int startGear) {
    gear = startGear;
    cadence = startCadence;
    speed = startSpeed;
}public Bicycle(int st
</code></pre>

<p>可以通过<code>new</code>操作符创建<code>Bicycle</code>的对象，并初始化相关的字段。</p>

<pre><code class="language-java">Bicycle myBike = new Bicycle(30, 0, 8);
</code></pre>

<p>和方法重载一样，一个类可以有多个构造函数，只要它们的方法签名不一样。例如，下面是一个无参数的构造函数</p>

<pre><code class="language-java">public Bicycle() {
    gear = 1;
    cadence = 10;
    speed = 0;
}
</code></pre>

<h2 id="方法中的参数传递">方法中的参数传递</h2>
<p>在Java中数据分为2种类型即，原始数据类型和引用数据类型，数据在传递给方法时，2种数据类型的传递方式是不同的。</p>

<h3 id="原始数据类型的传递">原始数据类型的传递</h3>
<p>原始数据类型是按值传递的，它传递的是该数据的值的拷贝，什么意思呢？请看下面的代码，假设我把值<code>99.00</code>传给<code>computePayment</code>方法，方法在内部把我传入的值修改变成了100，但是这个修改仅仅在方法内部有效，方法到<code>return</code>就结束了，在方法外部，我的值还是<code>99.00</code>。</p>

<pre><code class="language-java">public double computePayment(double loanAmt) {
    double loanAmt = 100.0;
    return loanAmt;
}
</code></pre>
<h3 id="引用类型的传递">引用类型的传递</h3>
<p>引用类型的数据是按引用传递的，它传递的是该数据的内存地址的引用。什么意思呢？下面的代码中，我通过调用<code>circle</code>对象的<code>setX</code>和<code>setY</code>方法，对它的成员变量<code>x</code>和<code>y</code>进行了修改，和值传递不同的是，它的修改是永久的，当方法运行结束，该修改仍然有效。</p>

<pre><code class="language-java">public void moveCircle(Circle circle, int deltaX, int deltaY) {
    // code to move origin of circle to x+deltaX, y+deltaY
    circle.setX(circle.getX() + deltaX);
    circle.setY(circle.getY() + deltaY);
        
    // code to assign a new reference to circle
    circle = new Circle(0, 0);
}
</code></pre>

<h2 id="参考">参考</h2>
<p><a href="https://docs.oracle.com/javase/tutorial/java/javaOO/arguments.html">The Java™ Tutorials</a></p>

	  ]]></description>
	</item>

	<item>
	  <title>Java学习笔记(三) - 表达式、语句和块</title>
	  <link>//Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%89)-%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E8%AF%AD%E5%8F%A5%E5%92%8C%E5%9D%97</link>
	  <author></author>
	  <pubDate>2018-08-28T00:00:00+08:00</pubDate>
	  <guid>//Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%89)-%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E8%AF%AD%E5%8F%A5%E5%92%8C%E5%9D%97</guid>
	  <description><![CDATA[
	     <h2 id="表达式">表达式</h2>
<p>表达式是由变量、操作符和方法调用组成的一个就算过程，它一定有单个的返回值，下面是表达式的例子：</p>

<pre><code class="language-java">int code = 1;

if (value1 == value2) 
    System.out.println("value1 == value2");
</code></pre>

<p>在上面的示例中，<code>code = 1</code>是一个表达式，它返回一个<code>int</code>类型的值，表达式的返回值也可以是其它类型，<code>value1 == value2</code>是一个返回布尔值的表达式。Java语言也可以通过各种较小的表达式构成符合表达式，如下所示：</p>

<pre><code class="language-java">1 * 2 * 3
</code></pre>

<h2 id="语句">语句</h2>
<p>通俗的讲语句就是自然语言中的句子。一条一句是一个完整的执行单元，表达是是语句的一部分，下面这些类型的表达式，在其后面加上分号就变成语句了。</p>

<ul>
  <li>
    <p>赋值表达式</p>
  </li>
  <li>
    <p>使用了<code>++</code>或者<code>--</code>的表达式</p>
  </li>
  <li>
    <p>方法调用</p>
  </li>
  <li>
    <p>对象的创建</p>
  </li>
</ul>

<p>这些语句被称为表达式语句，下面是一些表达式语句的例子。</p>

<pre><code class="language-java">// assignment statement
aValue = 8933.234;
// increment statement
aValue++;
// method invocation statement
System.out.println("Hello World!");
// object creation statement
Bicycle myBike = new Bicycle();
</code></pre>

<p>另外，语句可以分为<code>声明语句</code>和<code>控制流语句</code>，上面的例子是<code>声明语句</code>，下面的示例是<code>控制流语句</code>。</p>

<pre><code class="language-java">if (a === true) {
	// do something
}
</code></pre>

<h2 id="块">块</h2>
<p><strong>块</strong> 是语句的组合，在“块”的范围内可以有0或n个语句，<code>{}</code>花括号边上开始和结束，下面是块的示例。</p>

<pre><code class="language-java">
class BlockDemo {
     public static void main(String[] args) {
          boolean condition = true;
          if (condition) { // 开始 块 1
               System.out.println("Condition is true.");
          } // 结束 块 one
          else { // 开始 块 2
               System.out.println("Condition is false.");
          } // 结束 块 2
     }
}
</code></pre>

<h2 id="控制流语句">控制流语句</h2>
<p>控制流语分为3种，<strong>条件判断类型 ** (<code>if-then</code>,<code>if-then-else</code>,<code>switch</code>)、 **循环语句</strong> (<code>for</code>,<code>while</code>,<code>do-while</code>) 和 <strong>分支语句</strong> (<code>break</code>,<code>continue</code>,<code>return</code>)。</p>

<h3 id="条件判断语句">条件判断语句</h3>

<pre><code class="language-java">// if-then
 if (condition){ 
     // then do something
 }
    
// 省略括号的写法
 if (isMoving)
      currentSpeed--;

// if-then-else 
if (isMoving) {
       currentSpeed--;
   } else if {
       System.err.println("The bicycle has already stopped!");
   } else {
    // do something
}
	
// switch 语句
int month = 8;
String monthString;
switch (month) {
    case 1:  monthString = "January";
             break;
    case 2:  monthString = "February";
             break;
    default: monthString = "Invalid month";
             break;
}
    
</code></pre>

<h3 id="循环语句">循环语句</h3>
<pre><code class="language-java">// while语句
while (count &lt; 11) {
    System.out.println("Count is: " + count);
    count++;
}

// do while语句
do {
   statement(s)
} while (expression);

// for循环
class ForDemo {
    public static void main(String[] args){
         for(int i=1; i&lt;11; i++){
              System.out.println("Count is: " + i);
         }
    }
}

// for循环迭代的用法
class EnhancedForDemo {
    public static void main(String[] args){
         int[] numbers = 
             {1,2,3,4,5,6,7,8,9,10};
         for (int item : numbers) {
             System.out.println("Count is: " + item);
         }
    }
}

</code></pre>

<h3 id="分支语句">分支语句</h3>
<pre><code class="language-java">for (i = 0; i &lt; arrayOfInts.length; i++) {
    if (arrayOfInts[i] == searchfor) {
        foundIt = true;
        break; // 跳出循环
    }
}
</code></pre>

<h2 id="参考">参考</h2>
<p><a href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/expressions.html">The Java™ Tutorials</a></p>

	  ]]></description>
	</item>

	<item>
	  <title>Java学习笔记(二) - 原始数据类型</title>
	  <link>//Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)-%E5%8E%9F%E5%A7%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B</link>
	  <author></author>
	  <pubDate>2018-08-27T00:00:00+08:00</pubDate>
	  <guid>//Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)-%E5%8E%9F%E5%A7%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B</guid>
	  <description><![CDATA[
	     <h2 id="原始数据类型">原始数据类型</h2>
<p>Java是静态类型语言，所以变量必须先声明才能使用，并且每个变量都有自己的类型和名称。原始值不与其他原始数据值共享状态，Java语言定义了8种原始数据类型。</p>
<ul>
  <li><strong>byte</strong>   字节类型，在内存中占8位，它的值的范围是<code>-128 ~ 127</code>(包含)，在需要节省内存的情况下，字节类型可用来保存大型数组。</li>
  <li><strong>short</strong>  类型在内存中占16位，它的值的范围是<code>-32,768 ~ 32,767 </code>，和<code>byte</code>类型一样，同样适用于需要节省内存的情况。</li>
  <li><strong>int</strong> 类型在内存中占32位，它的值的范围是<strong>-2<sup>31</sup> ~ 2<sup>31</sup> -1</strong>。Java8之后可以使用无符号的整数，它的范围是**0 ~ 2<sup>32</sup> **，<code>Integer</code>中增加了静态方法<code>compareUnsigned</code>,<code>divideUnsigned</code>等方法可支持无符号整数运算。</li>
  <li><strong>long</strong>类型在内存中占64位，它的取值范围是<strong>-2<sup>63</sup> ~ 2<sup>63</sup> -1</strong>，Java8之后也可以使用无符号整数，通过<code>Long</code>类提供的<code>compareUnsigned</code>、<code>divideUnsigned</code>方法支持无符号整数运算。</li>
  <li><strong>float</strong>为32位单精度浮点类型。</li>
  <li><strong>dobule</strong>类型为64位双精度浮点类型。</li>
  <li><strong>boolean</strong>布尔类型，有<code>true/false</code>两种类型，通常用于条件判断<code>true</code>表<code>是</code>,<code>false</code>表<code>否</code>。</li>
  <li><strong>char</strong> 字符类型是单个16位<code>Unicode</code>字符，它的值范围是<code>'\u0000'</code>~<code>'\uffff'</code>。</li>
</ul>

<h2 id="默认值">默认值</h2>
<p>类的全局变量声明之后不是必须被分配的。如果全局变量被声明了，但是没有初始化，它会被编译器设置一个默认值，可能是<code>0</code>或<code>null</code>，这取决于数据类型，不过，依赖于默认值被认为是一种糟糕的编程风格。下表总结了各种数据类型对应的默认值</p>

<table>
  <thead>
    <tr>
      <th>数据类型</th>
      <th>默认值</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>byte</td>
      <td>0</td>
    </tr>
    <tr>
      <td>short</td>
      <td>0</td>
    </tr>
    <tr>
      <td>int</td>
      <td>0</td>
    </tr>
    <tr>
      <td>long</td>
      <td>0L</td>
    </tr>
    <tr>
      <td>float</td>
      <td>0.0f</td>
    </tr>
    <tr>
      <td>double</td>
      <td>0.0d</td>
    </tr>
    <tr>
      <td>char</td>
      <td>‘\u0000’</td>
    </tr>
    <tr>
      <td>String(或者 任何对象)</td>
      <td>null</td>
    </tr>
    <tr>
      <td>boolean</td>
      <td>false</td>
    </tr>
  </tbody>
</table>

<p>对于局部变量则不同，编译器永远不会给局部变量分配默认值，如果你在声明时未对该变量进行初始化，在你使用该变量之前必须对其初始化，否则将导致编译错误。</p>

<h2 id="字面量-literals">字面量-Literals</h2>
<p>在初始化原始数据类型时不需要<code>new</code>关键词，因为原始数据类型是语言中内置的数据类型，字面量就是原始数据类型变量的等号右边的，固定的值，可以是字符串或数字。如下所示，<code>100</code>和<code>true</code>就是字面量。</p>
<pre><code class="language-java">int a = 100;
boolean result = true;
</code></pre>
<p>字面量可以分为：</p>
<ul>
  <li><strong>整数字面量</strong></li>
  <li><strong>浮点数字面量</strong></li>
  <li><strong>字符串字面量</strong></li>
</ul>

<h2 id="参考">参考</h2>
<p><a href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html">The Java™ Tutorials</a></p>

	  ]]></description>
	</item>

	<item>
	  <title>Java学习笔记(一) - 变量</title>
	  <link>//Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)-%E5%8F%98%E9%87%8F</link>
	  <author></author>
	  <pubDate>2018-08-26T00:00:00+08:00</pubDate>
	  <guid>//Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)-%E5%8F%98%E9%87%8F</guid>
	  <description><![CDATA[
	     <h2 id="变量">变量</h2>
<p>Java语言定义了4中类型的变量</p>

<ul>
  <li><strong>实例变量</strong></li>
</ul>

<p>实例变量本质上是 <strong>一个类的非晶态的全局变量</strong>，注意关键词，<strong>非晶态</strong>和<strong>全局</strong>。为什么叫实例变量呢？因为它的值在类的每个实例都是唯一的，实例就是指对象。下面的例子中，有一个<code>Box</code>类，定义了一个全局变量<code>numbers=1</code>，在这里<code>box1</code>是类<code>Box</code>的第1个实例，<code>box2</code>是第2个实例，<code>numbers</code>变量在这2个实例中是独立的，修改了实例<code>box1</code>中的变量<code>numbers</code>不会对<code>box2</code>实例中的<code>numbers</code>造成影响。</p>

<pre><code class="language-java">class Box {
	public int numbers = 1;
}

Box box1 = new Box();
box1.numbers = 2;
Box box2 = new Box(); // box2的numbers属性依然是1
</code></pre>

<ul>
  <li><strong>类变量</strong></li>
</ul>

<p>类变量指的是<strong>一个类的静态全局变量</strong>，关键词是，<strong>静态</strong>和<strong>全局</strong>。为什么叫类变量呢？因为它是和实例(对象)无关的，不管一个类被实例化多少次，类变量都只有一份。静态变量通过<code>static</code>关键词来声明，对第1个例子稍作修改，<code>numbers</code>变成了类变量，<code>box1</code>调用<code>getNumbers</code>方法得到的值为1，然后我们把<code>numbers</code>的值改为了2，<code>box2</code>调用<code>getNumbers</code>的值变成了2，结果说明了<code>类变量</code>只和类有关 。</p>

<pre><code class="language-java">class Box {
	public static int numbers = 1;
	
	public int getNumbers() {
		return Box.numbers;
	}
}

Box box1 = new Box();
box1.getNumbers();// 得到的值为1
Box.numbers = 2; // 修改全局变量
Box box2 = new Box(); 
box2.getNumbers(); // 得到的值为2
</code></pre>

<ul>
  <li><strong>局部变量</strong></li>
</ul>

<p>Java中的局部变量是指<strong>类的方法内部的变量</strong>，局部变量仅在方法内部可见，在类的外部无法被访问到，通常用于存储一个方法的临时状态，在方法执行完成后，会自动释放掉。如下所示<code>getNumbers</code>方法中的<code>numbers</code>就是局部变量。</p>

<pre><code class="language-java">class Box {
	
	public int getNumbers() {
		int numbers = 1
		return numbers;
	}
}

</code></pre>

<ul>
  <li><strong>参数</strong></li>
</ul>

<p>参数变量是指方法中的参数，它的作用域和局部变量一样，仅在方法内有效，可以接受来自外部的数据。如下所示，<code>numbers</code>作为<code>getNumbers</code>方法的参数。</p>

<pre><code class="language-java">class Box {
	
	public void getNumbers(int numbers) {
		System.out.println(numbers);
	}
}

</code></pre>

<h2 id="命名规范">命名规范</h2>
<ul>
  <li>变量命名大小写敏感，不限制长度，可以由一系列Unicode的字符和数字组成，用<code>字母</code>，<code>$</code>和<code>_</code>都是被允许的，包括中文，技术上是不限制的，但是Java规范不建议用<code>$</code>和<code>_</code>作为开头。</li>
  <li>命名的尽量只用全称而非简称，写全称的代码可读性和可维护性都更好，好的命名，在很多情况下就是文档本身，另外需要注意，变量的名称不能为Java的关键词和保留字。</li>
  <li>变量名称涉及多个单词的，第二个单词开始开头字母大写，也就是驼峰命名法，例如<code>boxNumbers</code>。如果是常量或者不能改变的变量，所有字母都用大写，字母之间用<code>_</code>隔开，例如<code>BOX_CONFIG</code>。</li>
</ul>

<h2 id="参考">参考</h2>
<p><a href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/variables.html">The Java™ Tutorials</a></p>

	  ]]></description>
	</item>


</channel>
</rss>
