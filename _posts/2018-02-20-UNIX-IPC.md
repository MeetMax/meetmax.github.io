---
layout: post
cover: false
navigation: false
title: Unix进程间通信(IPC)
date: 2018-02-20 10:18:00
tags: unix
subclass: 'post tag-fiction'
logo: 'assets/images/ghost.png'
author: meetmax
categories: meetmax
---


### IPC概念:
> **进程间通信**（**IPC**，*Inter-Process Communication*），指至少两个[进程](https://zh.wikipedia.org/wiki/%E8%BF%9B%E7%A8%8B)或[线程](https://zh.wikipedia.org/wiki/%E7%BA%BF%E7%A8%8B)间传送数据或信号的一些技术或方法。进程是[计算机系统](https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F)分配资源的最小单位(严格说来是线程)。每个进程都有自己的一部分独立的系统资源，彼此是隔离的。为了能使不同的进程互相访问资源并进行协调工作，才有了进程间通信。举一个典型的例子，使用进程间通信的两个应用可以被分类为客户端和服务器（见**主从式架构**），客户端进程请求数据，服务端回复客户端的数据请求。有一些应用本身既是服务器又是客户端，这在**分布式计算**中，时常可以见到。这些[进程](https://zh.wikipedia.org/wiki/%E8%BF%9B%E7%A8%8B)可以运行在同一计算机上或网络连接的不同计算机上。
>
> 进程间通信技术包括消息传递、同步、共享内存和[远程过程调用](https://zh.wikipedia.org/wiki/%E8%BF%9C%E7%A8%8B%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8)。IPC是一种标准的[Unix](https://zh.wikipedia.org/wiki/Unix)通信机制。
>
> 使用IPC 的理由：
>
> - 信息共享：**Web服务器**，通过**网页浏览器**使用进程间通信来共享web文件（网页等）和多媒体；
> - 加速：维基百科使用通过进程间通信进行交流的多服务器来满足用户的请求；
> - 模块化;
> - 私有权分离.
>
> 与直接共享内存地址空间的[多线程编程](https://zh.wikipedia.org/wiki/%E5%A4%9A%E7%BA%BF%E7%A8%8B)相比，IPC的缺点：[[1\]](https://zh.wikipedia.org/wiki/%E8%A1%8C%E7%A8%8B%E9%96%93%E9%80%9A%E8%A8%8A#cite_note-1)
>
> - 采用了某种形式的内核开销，降低了性能;
> - 几乎大部分IPC都不是程序设计的自然扩展，往往会大大地增加程序的复杂度。

## 一、管道

#### 1、特点：

1. 管道是一种半双工的通信方式(即数据只能单向流动)，也有部分系统上实现了全双工的管道，出于程序可移植性考虑，建议使用半双工管道，全双工的通信可由其它方式实现，例如：消息队列，Unix域套接字。

2. 管道分为两种，无名管道和有名管道。

   - **无名管道：**

   最早出现的管道是没有名字的，因此只能用于父子进程间通信，父进程通过`fork()`系统调用创建一个子进程，然后通过管道通信。

   - **有名管道(FIFO):**

   有名管道也叫**FIFO**，由于磁盘中存在实际的管道文件，前者没有，所以叫有名管道。`FIFO`的意思是(first in ,first out)，先进先出。FIFO是一个(单向的)半双工数据流，不同于普通管道的是，每个FIFO都有一个对应文件的路径名与之关联，因此它能完成多个无亲缘关系进程之间的通信。

3. FIFO和无名管道的数据都存在内核的内存缓冲区中，大小一般为一页(4K)。不同的是，FIFO将内核缓冲区的数据映射到了实际的文件节点，可以在磁盘中看到对应的文件，所以叫**有名管道**，而无名管道在磁盘中没有对应文件，因此称**无名管道**。

4. 无名管道通过`<unistd.h>`头文件中的`pipe()`创建，有名管道(FIFO)通过`<sys/stat.h>`中的`mkfifo()`创建。

5. 管道通过`read()`和`write()`进行读写操作，管道内核缓冲区中的数据一旦被取走，管道中将不存在。当内核缓冲区满的时候，`write()`写操作将被阻塞，直到缓冲区有空闲再继续。同理，当缓冲区数据为空时，`read()`操作将阻塞，直到有新数据时再返回。

6. 当进程终止时，管道就完全被删除了。

- ###无名管道

#### 1、过程

1. 创建管道

   ```c
   #include <unistd.h>
   pipe(int fd[2]) 
   ```

2. 通过`fork()`创建子进程

   ```C
   // 返回值 >=0:成功 <0:错误
   // 如果是父进程则返回子进程 id,子进程则返回 0
   fork()
   ```

3. `read()`和`write()`读写缓冲区的数据

#### 2、例子

- *pipe.c*

```C
#include <unistd.h>
#include <stdio.h>

int main()
{
    int fd[2];	// 管道描述符
    pid_t pid;	// 进程id
    char buff[20];	// 缓冲区长度
    if(pipe(fd) < 0){
        printf("创建管道失败\n");
    }
    pid = fork();	// 创建子进程
    if(pid < 0){
        printf("fork()失败\n");
    }else if (pid > 0){	// 大于0为主进程
        close(fd[0]);	// 关闭主进程读端
        write(fd[1],"hello world\n",12);
    }else{ 	// 小于0为子进程
        close(fd[1]); 	// 关闭子进程写端
        sleep(2);
		read(fd[0], buff, 20);
		printf("读到的数据：%s\n", buff);
    }
    return 0;
}
```



- ### 有名管道FIFO

#### 1、过程

1. 按以下示例，先运行`read_fifo.c`，创建管道文件(**注意:** 此时管道文件必须不存在，否则会出错)。
2. 因为此时管道中还没有数据，`read()`处于阻塞状态，等待数据。
3. 再运行`write_fifo.c`，向管道中写入数据，此时`read()`打印`write_fifo.c`写入的数据。

#### 2、例子

- *read_fifo.c*

```C
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <fcntl.h>
#include <time.h>
#include <sys/stat.h>

int main()
{
    int fd,len;
    char buff[1024];	//管道缓冲区大小
  if(mkfifo("/Users/meetmax/CWork/fifo1", 0666) < 0)
  {		// 创建FIFO管道,此时`fif01`文件必须不存在，否则报错
    	perror("Create FIFO Failed");
    	exit(1);
  } 
  
	if((fd = open("/Users/meetmax/CWork/fifo1", O_RDONLY)) < 0) 
	{ 	// 以只读模式打开FIFO，和打开普通文件一样
		perror("Open FIFO Failed");
		exit(1);
	}
	 // 如果管道中有数据，读取FIFO管道
	while((len = read(fd, buff, 1024)) > 0)
		printf("Read message: %s", buff);

	close(fd);  // 关闭FIFO文件
	return 0;
}
```

- *write_fifo.c*

```C
#include<stdio.h>
#include<stdlib.h>   // exit
#include<fcntl.h>    // O_WRONLY
#include<sys/stat.h>
#include<time.h>     // time
#include <time.h>

int main()
{
	int fd;
	int n, i;
	char buf[1024];
	time_t tp;

	printf("I am %d process.\n", getpid()); // 说明进程ID
	
	if((fd = open("/Users/meetmax/CWork/fifo1", O_WRONLY)) < 0) 
      // 以写打开一个FIFO 
	{
		perror("Open FIFO Failed");
		exit(1);
	}

	for(i=0; i<10; ++i)
	{
		time(&tp);  // 取系统当前时间
		n=sprintf(buf,"Process %d's time is %s",getpid(),ctime(&tp));
		printf("Send message: %s", buf); //	打印
		if(write(fd, buf, n+1) < 0)  // 写入到FIFO中
		{
			perror("Write FIFO Failed");
			close(fd);
			exit(1);
		}
		sleep(1);  // 休眠1秒
	}

	close(fd);  // 关闭FIFO文件
	return 0;
}
```



## XIS IPC(基于System V 的IPC函数)

除管道外，还有3种IPC的进程间的通信，分别为：消息队列、信号量和共享内存。这3个IPC有两种实现方式，分别为基于**System V**和**POSIX**的进程间通信。

- *维基百科*

**System V**

> **UNIX系统五**[[来源请求\]](https://zh.wikipedia.org/wiki/Wikipedia:%E5%88%97%E6%98%8E%E6%9D%A5%E6%BA%90)（英语：UNIX System V），是[Unix](https://zh.wikipedia.org/wiki/Unix)[操作系统](https://zh.wikipedia.org/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F)众多版本中的一支。它最初由[AT&T](https://zh.wikipedia.org/wiki/AT%26T)开发，在1983年第一次发布，因此也被称为**AT&T System V**。

**POSIX**

> **可移植操作系统接口**（英语：Portable Operating System Interface，缩写为**POSIX**），是[IEEE](https://zh.wikipedia.org/wiki/IEEE)为要在各种[UNIX](https://zh.wikipedia.org/wiki/UNIX)[操作系统](https://zh.wikipedia.org/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F)上运行软件，而定义[API](https://zh.wikipedia.org/wiki/API)的一系列互相关联的标准的总称，其正式称呼为IEEE Std 1003，而国际标准名称为[ISO](https://zh.wikipedia.org/wiki/ISO)/[IEC](https://zh.wikipedia.org/wiki/IEC) 9945。

System V 出现比 POSIX 要早，可以说POSIX是对System V的改进，POSIX API使用比前者更加简单高效，但是为什么两者仍然同时存在呢？还是一个移植性的问题，虽然现在新的程序都基于POSIX标准，但是仍然有很多旧的程序使用了基于System V的IPC，因此两者都保留了。本文的IPC基于System V的IPC函数。

## 二、消息队列

### 1、特点

1. 消息队列是消息的链表，存储在内核中，由消息队列标识符标识。
2. 消息队列是随内核持续的，进程终止时，消息队列及其内容不会被删除，除非内核重启或者调用`msgctl()`显式的删除消息队列。
3. 消息队列没有维护引用计数器(打开文件有这种计数器)，所以队列被删除后，仍在使用该队列的进程会出错返回。

### 2、过程

1. 先定义消息队列结构`struct msg_form`，每条消息都包含：
   - 消息队列类型：`long`类型的`mtype`
   - 消息数据：`char *`类型的字符串
2. 通过文件的路径名和项目ID(0~255之间)，调用`ftok()`获取IPC，获取key值。创建`XSI IPC`结构都应指定一个键，这个键的数据类型是系统数据类型key_t，通常在头文件`<sys/types.h>`中定义。
3. 接着调用`msgget()`函数，使用key作为其中一个参数，由内核将`key`变成IPC的标识符，在这里就是消息队列ID。
4. 拿到IPC标识符后，通过`msgsnd()`和`msgrcv()`分别发送和接收消息。

### 3、示例

- *msg_client.c*

```C
#include <stdio.h>
#include <stdlib.h>
#include <sys/msg.h>
#include <unistd.h>


#define MSG_FILE "/Users/meetmax/CWork/msg_file"

// 消息结构
struct msg_form {
    long mtype;    
	char mtext[256];
};

int main(){
    int msqid;	// 消息队列id
    key_t key;	// 键值
    struct msg_form msg;

    //获取key值
    if((key = ftok(MSG_FILE,100)) < 0){
        perror("获取key值失败\n");
        exit(0);
    }

    printf("key 值为： %d",key);

    if((msqid = msgget(key,IPC_CREAT|0777)) < 0){
        perror("获取消息队列失败");
        exit(0);
    }
    printf("消息队列id: %d \n",msqid);
    printf("进程id: %d \n",getpid());

    msg.mtype = 888;	// 设置消息类型
    sprintf(msg.mtext,"hello,I'm client %d\n",getpid());
    msgsnd(msqid,&msg,sizeof(msg.mtext),0);

    // 获取777类型的消息
	msgrcv(msqid, &msg, 256, 999, 0);
	printf("Client: receive msg.mtext is: %s.\n", msg.mtext);
	printf("Client: receive msg.mtype is: %ld.\n", msg.mtype);
	return 0;
}
```

- *msg_server.c*

```C
#include <stdio.h>
#include <stdlib.h>
#include <sys/msg.h>
#include <unistd.h>

#define MSG_FILE "/Users/meetmax/CWork/msg_file"
struct msg_form{
    long mtype;
    char mtext[256];
};
int main()
{
    int msqid;
    key_t key;
    struct msg_form msg;
    //获取key值
    if((key = ftok(MSG_FILE,100)) < 0){
        perror("获取key失败");
        exit(1);
    }
    //打印key值
    printf("key的值为 %d \n",key);
    //根据key值创建消息队列
    if((msqid = msgget(key,IPC_CREAT|0777)) < 0){
        perror("创建消息队列失败");
        exit(1);
    }
    printf("消息队列id为 : %d \n",msqid);
    printf("进程id为 : %d \n",getpid());
    while(1)
    {
        //接受888类型的消息        
        msgrcv(msqid,&msg,256,888,0);
        printf("Server:receive msg.mtext: %s \n",msg.mtext);
        printf("Server:receive msg.xxx: %ld \n",msg.mtype);
        msg.mtype = 999;
        sprintf(msg.mtext,"hello I'm server: %d \n",getpid());
        //发送消息
        msgsnd(msqid,&msg,sizeof(msg.mtext),0);
    }
    return 0;
}
```

## 三、信号量

### 1、特点

1. 信号量类似锁机制，能够使临界区内的资源在某一时刻只能被一个进程访问。临界区是指多个进程或线程共享的内存空间，在访问临界区的时候，多个进程操作同一个资源，此时就存在竞态条件，通常在两个进程对同一个资源写操作时，会产生结果不一致的问题，因为我们不知道系统进程何时切换，这种情况也很难复现和调试。必须有一种机制来保证在同一时刻只能有一个进程访问临界区，信号量就提供了这种机制。

2. 信号量是一种特殊的变量，程序对它的访问都是**原子操作**，所谓原子操作，即是指不可被中断的操作，要实现原子操作单纯软件是不够的。虽然也能实现，但是效率很低，信号量是一种和硬件紧密结合的机制，它不会被系统进程切换和中断操作打断。本文以**二值信号量**为例子，二值信号量能实现互斥锁的功能，保证同一时间只能一个进程访问资源。

3. 信号量的P,V操作

   *来自维基百科*

> 计数信号量具备两种操作动作，之前称为 V（又称signal()）与 P（wait()）。 V操作会增加信号量 S的数值，P操作会减少它。
>
> 运作方式：
>
> 1. 初始化，给与它一个非负数的整数值。
> 2. 运行 P（wait()），信号量S的值将被减少。企图进入[临界区块](https://zh.wikipedia.org/wiki/%E8%87%A8%E7%95%8C%E5%8D%80%E6%AE%B5)的进程，需要先运行 P（wait()）。当信号量S减为负值时，进程会被挡住，不能继续；当信号量S不为负值时，进程可以获准进入临界区块。
> 3. 运行 V（又称signal()），信号量S的值会被增加。结束离开[临界区块](https://zh.wikipedia.org/wiki/%E8%87%A8%E7%95%8C%E5%8D%80%E6%AE%B5)的进程，将会运行 V（又称signal()）。当信号量S不为负值时，先前被挡住的其他进程，将可获准进入[临界区块](https://zh.wikipedia.org/wiki/%E8%87%A8%E7%95%8C%E5%8D%80%E6%AE%B5)。

### 2、过程

1. 获取`key`值(同消息队列)
2. 获取信号量ID(同消息队列)
3. `semctl()`函数初始化信号量
4. `fork()`子进程
5. 执行P,V操作

### 3、例子

*sem.c 二值信号量*

```C
#include <stdio.h>
#include <stdlib.h>
#include <sys/sem.h> // 信号量函数库
#include <unistd.h>

#define SEM_FILE "/Users/meetmax/CWork/sem_file" // 信号量文件

union sem_union //信号量联合
{
    int val;
    struct semid_ds *buf;
    unsigned short *array;
};

//初始化信号量
int init_sem(int sem_id,int val)
{
    union sem_union tmp;
    tmp.val = val;
    if((semctl(sem_id,0,SETVAL,tmp)) == -1)
    {
        perror("初始化信号量失败");
        return -1;
    }
    return 0;
}

/**
 * P操作
 * 信号量大于0时执行 -1 操作，获取资源
 * 若信号量 <= 0 则挂起等待
*/
int sem_p(int sem_id)
{
    struct sembuf sbuf;
    sbuf.sem_num = 0;
    sbuf.sem_op = -1;
    sbuf.sem_flg = SEM_UNDO;
    if(semop(sem_id,&sbuf,1) == -1)
    {
        perror("p操作失败");
        return -1;
    }
    return 0;
}

/**
 * V操作
 * 信号量 <= 0时执行，+1操作，释放资源
 * 若信号量 > 0 时挂起等待
 */
int sem_v(int sem_id)
{
    struct sembuf sbuf;
    sbuf.sem_num = 0;
    sbuf.sem_op = 1;
    sbuf.sem_flg = SEM_UNDO;
    if(semop(sem_id,&sbuf,1) == -1)
    {
        perror("V操作失败");
        return -1;
    }
    return 0;
}

//删除信号量
int sem_del(int sem_id)
{
    union sem_union tmp;
    if(semctl(sem_id,0,IPC_RMID,tmp) == -1)
    {
        perror("删除信号量失败");
        return -1;
    }
    return 0;
}

int main()
{
    int sem_id;
    key_t key;
    pid_t pid;

    //获取key值
    if((key = ftok(SEM_FILE,100)) == -1)
    {
        perror("获取key值失败");
        exit(1);
    }
    //获取信号量id
    if((sem_id = semget(key,1,IPC_CREAT|0666)) == -1)
    {
        perror("信号量id获取失败");
        exit(1);
    }

    //初始化信号量
    init_sem(sem_id,0);

    //fork进程
    if((pid = fork()) == -1)
    {
        perror("进程fork失败");
        exit(1);
    }else if(pid == 0){ //子进程
        printf("我是子进程：%d \n",getpid());
        sleep(2);
        sem_v(sem_id);
    }else if(pid > 0){ //父进程
        sem_p(sem_id);
        printf("我是父进程：%d \n",getpid());
        sem_v(sem_id);
        sem_del(sem_id);
    }
    return 0;
}
```

## 四、共享内存

### 1、特点

*概念*

> 顾名思义，共享内存就是允许两个不相关的进程访问同一个逻辑内存。共享内存是在两个正在运行的进程之间共享和传递数据的一种非常有效的方式。不同进程之间共享的内存通常安排为同一段物理内存。进程可以将同一段共享内存连接到它们自己的地址空间中，所有进程都可以访问共享内存中的地址，就好像它们是由用C语言函数malloc分配的内存一样。而如果某个进程向共享内存写入数据，所做的改动将立即影响到可以访问同一段共享内存的任何其他进程。

### 2、过程

1. `ftko()`获取key值(同消息队列)
2. 用`shmget()`函数获取共享内存ID
3. 进程通过`shmat()`函数连接共享内存
4. 访问共享内存

### 3、示例

*shm_server.c 读数据*

```C
#include <stdio.h>
#include <stdlib.h>
#include <sys/shm.h>
#include <string.h>

#define SHM_FILE "/Users/meetmax/CWork/shm_file"

int main()
{
    int shm_id;
    key_t key;
    char * shm;
    struct shmid_ds buf;
	// 获取key
    if((key = ftok(SHM_FILE,100)) == -1)
    {
        perror("获取key失败");
        exit(0);
    }
	// 获取共享内存描述符ID
    if((shm_id = shmget(key,512,IPC_CREAT|0666)) == -1)
    {
        perror("获取共享内存id失败");
        exit(0);
    }
	// 连接共享内存
    if((int)(shm = (char *)shmat(shm_id,0,0)) == -1)
    {
        perror("连接共享内存失败");
        exit(1);
    }
    printf("开始接收数据\n");
  
    // 开始忙等，接收数据
    while(1)
    {
        if(strlen(shm) > 0){
            printf("收到数据：%s \n",shm);
            sprintf(shm,"");
        }
        if(strcmp(shm,"r") == 0){
            printf("已退出\n");
            break;
        }
    }
    // 删除共享内存
    shmctl(shm_id,IPC_RMID,&buf);
    return 0;

}
```

*sem_client.c 写入数据* 

```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/shm.h>

#define SHM_FILE "/Users/meetmax/CWork/shm_file"

int main()
{
    int shm_id;
    key_t key;
    char * shm;
   
	// 获取key
    if((key = ftok(SHM_FILE,100)) == -1)
    {
        perror("获取key失败");
        exit(0);
    }
	// 获取共享内存id
    if((shm_id = shmget(key,512,IPC_CREAT|0666)) == -1)
    {
        perror("获取共享内存id失败");
        exit(0);
    }
	// 连接共享内存，若不存在则创建
    if((int)(shm = (char *)shmat(shm_id,0,0)) == -1)   
    {
        perror("连接共享内存失败");
        exit(1);
    }
    printf("请输入：");
    scanf("%s",shm); // 写入数据到共享内存
    shmdt(shm); // 断开连接
    return 0;
}
```

## 参考

- *《UNIX环境高级编程》*
- *《UNIX网络编程：卷2》*
-   部分来自互联网